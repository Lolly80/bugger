// Generated by CoffeeScript 1.6.1
(function() {
  var Buffer, EventEmitter, Net, callbackHandler, makeMessage;

  Net = require('net');

  EventEmitter = require('events').EventEmitter;

  Buffer = require('buffer').Buffer;

  callbackHandler = require('./callback').create();

  makeMessage = function() {
    return {
      headersDone: false,
      headers: null,
      contentLength: 0
    };
  };

  exports.attachDebugger = function(debugConnection) {
    var conn, connected, debugBuffer, debugr, msg, parse;
    connected = debugConnection.writable;
    debugBuffer = '';
    msg = false;
    conn = debugConnection;
    conn.setEncoding('utf8');
    parse = function() {
      var b, contentLengthMatch, obj, offset;
      if (msg && msg.headersDone) {
        if (Buffer.byteLength(debugBuffer) >= msg.contentLength) {
          b = new Buffer(debugBuffer);
          msg.body = b.toString('utf8', 0, msg.contentLength);
          debugBuffer = b.toString('utf8', msg.contentLength, b.length);
          if (msg.body.length > 0) {
            obj = JSON.parse(msg.body);
            if (obj.type === 'response' && obj.request_seq > 0) {
              callbackHandler.processResponse(obj.request_seq, [obj]);
            } else if (obj.type === 'event') {
              debugr.emit(obj.event, obj);
            }
          }
          msg = false;
          return parse();
        }
      } else {
        if (!msg) {
          msg = makeMessage();
        }
        offset = debugBuffer.indexOf('\r\n\r\n');
        if (offset > 0) {
          msg.headersDone = true;
          msg.headers = debugBuffer.substr(0, offset + 4);
          contentLengthMatch = /Content-Length: (\d+)/.exec(msg.headers);
          if (contentLengthMatch[1]) {
            msg.contentLength = parseInt(contentLengthMatch[1], 10);
          } else {
            console.warn('no Content-Length');
          }
          debugBuffer = debugBuffer.slice(offset + 4);
          return parse();
        }
      }
    };
    debugr = Object.create(EventEmitter.prototype, {
      send: {
        value: function(data) {
          if (connected) {
            return conn.write("Content-Length: " + data.length + "\r\n\r\n" + data);
          } else {
            return console.log('[debug] Not connected');
          }
        }
      },
      request: {
        value: function(command, params, callback) {
          msg = {
            seq: 0,
            type: 'request',
            command: command
          };
          if ('function' === typeof callback) {
            msg.seq = callbackHandler.wrap(callback);
          }
          if (params) {
            Object.keys(params).forEach(function(key) {
              return msg[key] = params[key];
            });
          }
          return this.send(JSON.stringify(msg));
        }
      },
      close: {
        value: function() {
          console.trace('debugger#close was called');
          return conn.end();
        }
      },
      connected: {
        get: function() {
          return connected;
        }
      }
    });
    conn.on('connect', function() {
      connected = true;
      return debugr.emit('connect');
    });
    conn.on('data', function(data) {
      debugBuffer += data;
      return parse();
    });
    conn.on('error', function(e) {
      return debugr.emit('error', e);
    });
    conn.on('end', function() {
      return debugr.close();
    });
    conn.on('close', function() {
      connected = false;
      return debugr.emit('close');
    });
    return debugr;
  };

}).call(this);
