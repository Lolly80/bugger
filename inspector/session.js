// Generated by CoffeeScript 2.0.0-beta4
var debugr, events;
events = require('events');
debugr = require('./debugger');
exports.create = function (debugConnection, config) {
  var agents, breakEvent, breakpoints, browserConnected, conn, cpuProfileCount, debug, dispatchEvent, evaluate, FUNC_WRAP, LOOKUP_TIMEOUT, mapCallFrames, parsedScripts, refToObject, sendBacktrace, sendEvent, sendProfileHeader, sendResponse, sourceIDs, sourceMaps, sourceUrls, wrapperObject;
  debug = null;
  conn = null;
  breakpoints = {};
  sourceIDs = {};
  sourceUrls = {};
  sourceMaps = {};
  LOOKUP_TIMEOUT = 2500;
  FUNC_WRAP = /^\(function \(exports, require, module, __filename, __dirname\) \{ ([\s\S]*)\n\}\)$/;
  cpuProfileCount = 0;
  agents = {
    Debugger: {
      enable: function (cb) {
        console.log('Debbuger#enable');
        return cb(null, true);
      },
      disable: function (cb) {
        console.log('Debbuger#disable');
        return cb(null, true);
      },
      setPauseOnExceptions: function (param$, cb) {
        var state;
        state = param$.state;
        console.log('Debugger#setPauseOnExceptions', arguments[0]);
        return cb(null, true);
      },
      setBreakpointsActive: function (param$, cb) {
        var active;
        active = param$.active;
        console.log('Debugger#setBreakpointsActive', arguments[0]);
        return cb(null, true);
      },
      removeBreakpoint: function (param$, cb) {
        var breakpointId;
        breakpointId = param$.breakpointId;
        return debug.request('clearbreakpoint', { 'arguments': { breakpoint: breakpointId } }, function (msg) {
          var id;
          for (id in breakpoints) {
            if (breakpoints[id] === breakpointId) {
              delete breakpoints[id];
              break;
            }
          }
          return cb(null);
        });
      },
      setBreakpointByUrl: function (param$, cb) {
        var args, bp, cache$, columnNumber, condition, enabled, lineNumber, sourceID, url;
        {
          cache$ = param$;
          lineNumber = cache$.lineNumber;
          url = cache$.url;
          columnNumber = cache$.columnNumber;
          condition = cache$.condition;
        }
        console.log('setBreakpointByUrl', arguments);
        enabled = true;
        sourceID = sourceUrls[url];
        if (bp = breakpoints[sourceID + ':' + lineNumber]) {
          args = {
            'arguments': {
              breakpoint: bp.breakpointId,
              enabled: enabled,
              condition: condition
            }
          };
          return debug.request('changebreakpoint', args, function (msg) {
            bp.enabled = enabled;
            bp.condition = condition;
            return cb(null, bp.breakpointId, bp.locations);
          });
        } else {
          args = {
            type: 'scriptId',
            target: sourceID,
            line: lineNumber,
            enabled: enabled,
            condition: condition
          };
          return debug.request('setbreakpoint', { 'arguments': args }, function (msg) {
            var b;
            if (msg.success) {
              b = msg.body;
              bp = breakpoints[b.script_id + ':' + b.line] = {
                sourceID: b.script_id,
                url: sourceIDs[b.script_id].url,
                line: b.line,
                breakpointId: b.breakpoint.toString(),
                locations: b.actual_locations.map(function (l) {
                  return {
                    scriptId: l.script_id.toString(),
                    lineNumber: l.line,
                    columnNumber: l.column
                  };
                }),
                enabled: enabled,
                condition: condition
              };
              return cb(null, bp.breakpointId, bp.locations);
            }
          });
        }
      },
      pause: function (cb) {
        console.log('Debugger#pause');
        return debug.request('suspend', {}, function (msg) {
          return breakEvent();
        });
      },
      resume: function (cb) {
        console.log('Debugger#resume');
        return debug.request('continue', {}, function (msg) {
          return cb(null, true);
        });
      },
      stepOver: function (cb) {
        return debug.request('continue', { 'arguments': { stepaction: 'next' } }, function (msg) {
          return cb(null, true);
        });
      },
      stepInto: function () {
        return debug.request('continue', { 'arguments': { stepaction: 'in' } }, function (msg) {
          return cb(null, true);
        });
      },
      stepOutOfFunction: function () {
        return debug.request('continue', { 'arguments': { stepaction: 'out' } }, function (msg) {
          return cb(null, true);
        });
      },
      getScriptSource: function (param$, cb) {
        var args, scriptId;
        scriptId = param$.scriptId;
        args = {
          'arguments': {
            includeSource: true,
            types: 4,
            ids: [scriptId]
          }
        };
        return debug.request('scripts', args, function (msg) {
          return cb(null, msg.body[0].source);
        });
      }
    },
    Console: {
      enable: function (cb) {
        console.log('Console#enable');
        return cb(null, true);
      }
    },
    Runtime: {
      evaluate2: function (options, cb) {
        var args, cache$, doNotPauseOnExceptions, expression, includeCommandLineAPI, objectGroup, returnByValue;
        console.log('Runtime#evaluate', options);
        cache$ = options;
        expression = cache$.expression;
        objectGroup = cache$.objectGroup;
        includeCommandLineAPI = cache$.includeCommandLineAPI;
        doNotPauseOnExceptions = cache$.doNotPauseOnExceptions;
        returnByValue = cache$.returnByValue;
        args = {
          expression: expression,
          disable_break: doNotPauseOnExceptions,
          global: true,
          maxStringLength: 1e5
        };
        console.log('Runtime#evaluate - mapped', args);
        return debug.request('evaluate', { 'arguments': args }, function () {
          console.log('Runtime#evaluate - cb', args);
          console.log('Options: ', options);
          console.log('Returned: ', arguments);
          return cb.apply(null, [].slice.call(arguments).concat());
        });
      },
      getProperties: function (param$, cb) {
        var cache$, cache$1, frame, handle, handles, objectId, ownProperties, ref, scope, timeout;
        {
          cache$ = param$;
          objectId = cache$.objectId;
          ownProperties = cache$.ownProperties;
        }
        cache$1 = objectId.split(':');
        frame = cache$1[0];
        scope = cache$1[1];
        ref = cache$1[2];
        if (ref === 'backtrace') {
          return debug.request('scope', {
            'arguments': {
              number: scope,
              frameNumber: frame,
              inlineRefs: true
            }
          }, function (msg) {
            var refs;
            if (msg.success) {
              refs = {};
              if (msg.refs && Array.isArray(msg.refs))
                msg.refs.forEach(function (r) {
                  return refs[r.handle] = r;
                });
              return cb(null, msg.body.object.properties.map(function (p) {
                var r;
                r = refs[p.value.ref];
                return {
                  name: p.name,
                  value: refToObject(r)
                };
              }));
            }
          });
        } else {
          handle = parseInt(ref, 10);
          timeout = setTimeout(function () {
            var seq;
            cb(null, [{
                name: 'sorry',
                value: wrapperObject('string', 'lookup timed out', false, 0, 0, 0)
              }]);
            return seq = 0;
          }, LOOKUP_TIMEOUT);
          handles = [handle];
          return debug.request('lookup', {
            'arguments': {
              handles: handles,
              includeSource: false
            }
          }, function (msg) {
            var obj, objProps, props, proto, r, refs;
            clearTimeout(timeout);
            if (msg.success) {
              refs = {};
              props = [];
              if (msg.refs && Array.isArray(msg.refs)) {
                obj = msg.body[handle];
                objProps = obj.properties;
                proto = obj.protoObject;
                for (var i$ = 0, length$ = msg.refs.length; i$ < length$; ++i$) {
                  r = msg.refs[i$];
                  refs[r.handle] = r;
                }
                props = objProps.map(function (p) {
                  r = refs[p.ref];
                  return {
                    name: String(p.name),
                    value: refToObject(r)
                  };
                });
                if (proto)
                  props.push({
                    name: '__proto__',
                    value: refToObject(refs[proto.ref])
                  });
              }
              return cb(null, props);
            } else {
              return console.log('[error] Runtime#getProperties', msg);
            }
          });
        }
      }
    }
  };
  wrapperObject = function (type, description, hasChildren, frame, scope, ref) {
    return {
      type: type,
      description: description,
      hasChildren: hasChildren,
      objectId: '' + frame + ':' + scope + ':' + ref
    };
  };
  refToObject = function (ref) {
    var desc, kids, name;
    desc = '';
    name = null;
    kids = ref.properties ? ref.properties.length : false;
    switch (ref.type) {
    case 'object':
      name = /#<an?\s(\w+)>/.exec(ref.text);
      if ((null != name ? name.length : void 0) > 1) {
        desc = name[1];
        if (desc === 'Array') {
          desc += '[' + (ref.properties.length - 1) + ']';
        } else if (desc === 'Buffer') {
          desc += '[' + (ref.properties.length - 4) + ']';
        }
      } else {
        desc = null != ref.className ? ref.className : 'Object';
      }
      break;
    case 'function':
      desc = null != ref.text ? ref.text : 'function()';
      break;
    default:
      desc = null != ref.text ? ref.text : '';
    }
    if (desc.length > 100)
      desc = desc.substring(0, 100) + '\u2026';
    return wrapperObject(ref.type, desc, kids, 0, 0, ref.handle);
  };
  mapCallFrames = function (bt) {
    if (bt.body.totalFrames > 0) {
      console.log(bt.body.frames.map(function (frame, idx) {
        return '[frame ' + idx + '] ' + frame.func.scriptId.toString() + ' @ ' + frame.line + ';' + frame.column + ' (' + frame.func.inferredName + ')';
      }));
      return bt.body.frames.map(function (frame) {
        return {
          id: frame.index,
          functionName: frame.func.inferredName,
          type: 'function',
          worldId: 1,
          location: {
            scriptId: frame.func.scriptId.toString(),
            lineNumber: frame.line,
            columnNumber: frame.column
          },
          scopeChain: frame.scopes.map(function (scope) {
            return {
              object: wrapperObject('object', frame.receiver.className, true, frame.index, scope.index, frame.receiver.ref),
              objectId: frame.index + ':' + scope.index + ':backtrace',
              type: function () {
                switch (scope.type) {
                case 1:
                  return 'local';
                case 2:
                  return 'with';
                case 3:
                  return 'closure';
                case 4:
                  return 'global';
                }
              }.call(this)
            };
          })
        };
      });
    } else {
      return [{
          type: 'program',
          location: { scriptId: 'internal' },
          line: 0,
          id: 0,
          worldId: 1,
          scopeChain: []
        }];
    }
  };
  evaluate = function (expr, frame, andThen) {
    var args;
    args = {
      expression: expr,
      disable_break: true,
      global: true,
      maxStringLength: 1e5
    };
    if (null != frame) {
      args.frame = frame;
      args.global = false;
    }
    return debug.request('evaluate', { 'arguments': args }, andThen);
  };
  sendBacktrace = function () {
    return debug.request('backtrace', { 'arguments': { inlineRefs: true } }, function (msg) {
      var callFrames;
      callFrames = mapCallFrames(msg);
      return dispatchEvent('Debugger.paused', { details: callFrames });
    });
  };
  breakEvent = function (obj) {
    var args, scriptId, source;
    scriptId = null != obj ? obj.body.script.id : null;
    if (null != scriptId)
      source = sourceIDs[scriptId];
    if (!(null != source)) {
      args = {
        'arguments': {
          includeSource: true,
          types: 4,
          ids: null != scriptId ? [obj.body.script.id] : void 0
        }
      };
      debug.request('scripts', args, parsedScripts);
    } else if (null != source ? source.hidden : void 0) {
      debug.request('continue', { 'arguments': { stepaction: 'out' } });
      return;
    }
    return sendBacktrace();
  };
  parsedScripts = function (msg) {
    var paths, scripts, shorten;
    scripts = msg.body.map(function (s) {
      return {
        scriptId: String(s.id),
        url: s.name,
        data: s.source,
        startLine: s.lineOffset,
        path: String(s.name).split('/'),
        isContentScript: false
      };
    });
    scripts.sort(function (a, b) {
      return a.path.length - b.path.length;
    });
    paths = [];
    shorten = function (s) {
      var i, p;
      for (var i$ = 0, length$ = function () {
            var accum$;
            var accum$;
            accum$ = [];
            for (var i$1 = s.length - 1; s.length - 1 <= 0 ? i$1 <= 0 : i$1 >= 0; s.length - 1 <= 0 ? ++i$1 : --i$1)
              accum$.push(i$1);
            return accum$;
          }.apply(this, arguments).length; i$ < length$; ++i$) {
        i = function () {
          var accum$;
          var accum$;
          accum$ = [];
          for (var i$1 = s.length - 1; s.length - 1 <= 0 ? i$1 <= 0 : i$1 >= 0; s.length - 1 <= 0 ? ++i$1 : --i$1)
            accum$.push(i$1);
          return accum$;
        }.apply(this, arguments)[i$];
        p = s.slice(i).join('/');
        if (paths.indexOf(p) === -1) {
          paths.push(p);
          return p;
        }
      }
      return s.join('/');
    };
    return scripts.forEach(function (s) {
      var hidden, item, sourceMapMatch;
      hidden = config.hidden && config.hidden.some(function (r) {
        return r.test(s.url);
      });
      sourceMapMatch = s.data.match(/\s\/\/@ sourceMappingURL=data:application\/json;base64,(.*)/);
      s.sourceMapURL = null;
      if (sourceMapMatch) {
        s.sourceMapURL = '/_sourcemap/' + s.scriptId;
        sourceMaps[s.scriptId.toString()] = JSON.parse(new Buffer(sourceMapMatch[1], 'base64').toString('utf8'));
      }
      item = {
        hidden: hidden,
        path: s.url
      };
      s.url = s.path.join('/');
      item.url = s.url;
      sourceIDs[s.scriptId] = item;
      sourceUrls[item.url] = s.scriptId;
      delete s.path;
      if (!hidden)
        return dispatchEvent('Debugger.scriptParsed', s);
    });
  };
  sendProfileHeader = function (title, uid, type) {
    return sendEvent('addProfileHeader', {
      header: {
        title: title,
        uid: uid,
        typeId: type
      }
    });
  };
  sendEvent = function (name, data) {
    if (null == data)
      data = {};
    if (conn)
      return conn.send(JSON.stringify({
        type: 'event',
        event: name,
        data: data
      }));
  };
  dispatchEvent = function (method, params) {
    if (null == params)
      params = {};
    if (conn) {
      return conn.send(JSON.stringify({
        method: method,
        params: params
      }));
    } else {
      return console.log('Could not send: ', method, params);
    }
  };
  sendResponse = function (seq, success, data) {
    if (null == data)
      data = {};
    if (conn)
      return conn.send(JSON.stringify({
        id: seq,
        error: null,
        result: data
      }));
  };
  browserConnected = function () {
    var args;
    args = {
      'arguments': {
        includeSource: true,
        types: 4
      }
    };
    console.log('[debug.request] scripts', args);
    return debug.request('scripts', args, function (msg) {
      console.log('[debug.response] scripts');
      parsedScripts(msg);
      return debug.request('listbreakpoints', {}, function (msg) {
        msg.body.breakpoints.forEach(function (bp) {
          var data;
          if (bp.type === 'scriptId') {
            data = {
              sourceID: bp.script_id,
              url: sourceIDs[bp.script_id].url,
              line: bp.line,
              enabled: bp.active,
              condition: bp.condition,
              number: bp.number
            };
            breakpoints[bp.script_id + ':' + bp.line] = data;
            return sendEvent('restoredBreakpoint', data);
          }
        });
        if (!msg.running)
          return sendBacktrace();
      });
    });
  };
  return Object.create(events.EventEmitter.prototype, {
    getSourceMap: {
      value: function (id) {
        return sourceMaps[id];
      }
    },
    attach: {
      value: function () {
        var this$;
        debug = debugr.attachDebugger(debugConnection);
        debug.on('break', breakEvent);
        debug.on('close', (this$ = this, function () {
          debug = {
            request: function () {
              return console.error('debugger not connected');
            }
          };
          sendEvent('debuggerWasDisabled');
          return this$.close();
        }));
        debug.on('connect', function () {
          return browserConnected();
        });
        debug.on('exception', function (msg) {
          return breakEvent(msg);
        });
        return debug.on('error', function (e) {
          var data, err;
          sendEvent('showPanel', { name: 'console' });
          err = e.toString();
          if (err.match(/ECONNREFUSED/))
            err += '\nIs node running with --debug?';
          data = {
            messageObj: {
              source: 3,
              type: 0,
              level: 3,
              line: 0,
              url: '',
              groupLevel: 7,
              repeatCount: 1,
              message: err
            }
          };
          return sendEvent('addConsoleMessage', data);
        });
      }
    },
    close: {
      value: function () {
        if (debug && debug.connected)
          debug.close();
        return this.emit('close');
      }
    },
    enableDebugger: {
      value: function (always) {
        return this.attach();
      }
    },
    dispatchOnInjectedScript: {
      value: function (injectedScriptId, methodName, argString, seq) {
        var args, data, evalResponse, expr, frame, handle, objectId, ref, scope, timeout, tokens;
        args = JSON.parse(argString);
        if (methodName === 'getProperties') {
          objectId = args[0];
          tokens = objectId.split(':');
          frame = parseInt(tokens[0], 10);
          scope = parseInt(tokens[1], 10);
          ref = tokens[2];
          if (ref === 'backtrace') {
            return debug.request('scope', {
              'arguments': {
                number: scope,
                frameNumber: frame,
                inlineRefs: true
              }
            }, function (msg) {
              var props, refs;
              if (msg.success) {
                refs = {};
                if (msg.refs && Array.isArray(msg.refs))
                  msg.refs.forEach(function (r) {
                    return refs[r.handle] = r;
                  });
                props = msg.body.object.properties.map(function (p) {
                  var r;
                  r = refs[p.value.ref];
                  return {
                    name: p.name,
                    value: refToObject(r)
                  };
                });
                return sendResponse(seq, true, { result: props });
              }
            });
          } else {
            handle = parseInt(ref, 10);
            timeout = setTimeout(function () {
              sendResponse(seq, true, {
                result: [{
                    name: 'sorry',
                    value: wrapperObject('string', 'lookup timed out', false, 0, 0, 0)
                  }]
              });
              return seq = 0;
            }, LOOKUP_TIMEOUT);
            return debug.request('lookup', {
              'arguments': {
                handles: [handle],
                includeSource: false
              }
            }, function (msg) {
              var obj, objProps, props, proto, refs;
              clearTimeout(timeout);
              if (msg.success && seq !== 0) {
                refs = {};
                props = [];
                if (msg.refs && Array.isArray(msg.refs)) {
                  obj = msg.body[handle];
                  objProps = obj.properties;
                  proto = obj.protoObject;
                  msg.refs.forEach(function (r) {
                    return refs[r.handle] = r;
                  });
                  props = objProps.map(function (p) {
                    var r;
                    r = refs[p.ref];
                    return {
                      name: String(p.name),
                      value: refToObject(r)
                    };
                  });
                  if (proto)
                    props.push({
                      name: '__proto__',
                      value: refToObject(refs[proto.ref])
                    });
                }
                return sendResponse(seq, true, { result: props });
              }
            });
          }
        } else if (methodName === 'getCompletions') {
          expr = args[0];
          data = {
            result: {},
            isException: false
          };
          if (expr === '') {
            sendResponse(seq, true, data);
            return;
          }
          return evaluate(expr, args[2], function (msg) {
            if (msg.success && msg.body.properties && msg.body.properties.length < 256)
              msg.body.properties.forEach(function (p) {
                return data.result[p.name] = true;
              });
            return sendResponse(seq, true, data);
          });
        } else {
          evalResponse = function (msg) {
            if (msg.success) {
              return sendResponse(seq, true, {
                result: refToObject(msg.body),
                isException: false
              });
            } else {
              return sendResponse(seq, true, {
                result: {
                  type: 'error',
                  description: msg.message
                },
                isException: false
              });
            }
          };
          if (methodName === 'evaluateInCallFrame') {
            return evaluate(args[1], args[0], evalResponse);
          } else if (methodName === 'evaluate') {
            return evaluate(args[0], null, evalResponse);
          }
        }
      }
    },
    disableDebugger: {
      value: function (always) {
        if (debug && debug.connected)
          return debug.close();
      }
    },
    populateScriptObjects: {
      value: function (seq) {
        return sendResponse(seq, true, {});
      }
    },
    getInspectorState: {
      value: function (seq) {
        return sendResponse(seq, true, {
          state: {
            monitoringXHREnabled: false,
            resourceTrackingEnabled: false
          }
        });
      }
    },
    getResourceContent: {
      value: function (identifier, encode) {
      }
    },
    enableProfiler: {
      value: function (always) {
        if (debug && debug.connected) {
          return evaluate('process.profiler !== undefined', null, function (msg) {
            if (msg.body.value) {
              return sendEvent('profilerWasEnabled');
            } else {
              sendEvent('showPanel', { name: 'console' });
              return sendEvent('addConsoleMessage', {
                messageObj: {
                  source: 3,
                  type: 0,
                  level: 2,
                  line: 0,
                  url: '',
                  repeatCount: 1,
                  message: 'you must require("v8-profiler") to use the profiler'
                }
              });
            }
          });
        } else {
          sendEvent('showPanel', { name: 'console' });
          return sendEvent('addConsoleMessage', {
            messageObj: {
              source: 3,
              type: 0,
              level: 2,
              line: 0,
              url: '',
              repeatCount: 1,
              message: 'not connected to node'
            }
          });
        }
      }
    },
    disableProfiler: {
      value: function (always) {
      }
    },
    clearConsoleMessages: {
      value: function () {
        return sendEvent('consoleMessagesCleared');
      }
    },
    activateBreakpoints: {
      value: function () {
        return Object.keys(breakpoints).forEach(function (key) {
          var bp;
          bp = breakpoints[key];
          return debug.request('changebreakpoint', {
            'arguments': {
              breakpoint: bp.number,
              condition: bp.condition,
              enabled: true
            }
          }, function (msg) {
            if (msg.success) {
              bp.enabled = true;
              return sendEvent('restoredBreakpoint', bp);
            }
          });
        });
      }
    },
    deactivateBreakpoints: {
      value: function (injectedScriptId, objectGroup) {
        return Object.keys(breakpoints).forEach(function (key) {
          var bp;
          bp = breakpoints[key];
          return debug.request('changebreakpoint', {
            'arguments': {
              breakpoint: bp.number,
              condition: bp.condition,
              enabled: false
            }
          }, function (msg) {
            if (msg.success) {
              bp.enabled = false;
              return sendEvent('restoredBreakpoint', bp);
            }
          });
        });
      }
    },
    pause: {
      value: function () {
        return debug.request('suspend', {}, function (msg) {
          if (!msg.running)
            return sendBacktrace();
        });
      }
    },
    resume: {
      value: function () {
        debug.request('continue');
        return sendEvent('resumedScript');
      }
    },
    stepOverStatement: {
      value: function () {
        debug.request('continue', { 'arguments': { stepaction: 'next' } });
        return sendEvent('resumedScript');
      }
    },
    stepIntoStatement: {
      value: function () {
        debug.request('continue', { 'arguments': { stepaction: 'in' } });
        return sendEvent('resumedScript');
      }
    },
    stepOutOfFunction: {
      value: function () {
        debug.request('continue', { 'arguments': { stepaction: 'out' } });
        return sendEvent('resumedScript');
      }
    },
    setPauseOnExceptionsState: {
      value: function (state, seq) {
        var params;
        params = {
          'arguments': {
            flags: [{
                name: 'breakOnCaughtException',
                value: state === 1
              }]
          }
        };
        return debug.request('flags', params, function (msg) {
          var value;
          value = 0;
          if (msg.success) {
            if (msg.body.flags.some(function (x) {
                return x.name === 'breakOnCaughtException' && x.value;
              }))
              value = 1;
            return sendResponse(seq, true, { pauseOnExceptionState: value });
          }
        });
      }
    },
    editScriptSource: {
      value: function (sourceID, newContent, seq) {
        var args;
        args = {
          script_id: sourceID,
          preview_only: false,
          new_source: newContent
        };
        return debug.request('changelive', { 'arguments': args }, function (msg) {
          var fs, match, newSource;
          sendResponse(seq, true, {
            success: msg.success,
            newBodyOrErrorMessage: msg.message || newContent
          });
          if (msg.success && config.saveLiveEdit) {
            fs = require('fs');
            match = FUNC_WRAP.exec(newContent);
            newSource = null;
            if (match && sourceIDs[sourceID] && sourceIDs[sourceID].path) {
              newSource = match[1];
              return fs.writeFile(sourceIDs[sourceID].path, newSource, function (e) {
                var data, err;
                if (!e)
                  return null;
                err = e.toString();
                data = {
                  messageObj: {
                    source: 3,
                    type: 0,
                    level: 3,
                    line: 0,
                    url: '',
                    groupLevel: 7,
                    repeatCount: 1,
                    message: err
                  }
                };
                return sendEvent('addConsoleMessage', data);
              });
            }
          }
        });
      }
    },
    getScriptSource: {
      value: function (sourceID, seq) {
        var args;
        args = {
          'arguments': {
            includeSource: true,
            types: 4,
            ids: [sourceID]
          }
        };
        return debug.request('scripts', args, function (msg) {
          return sendResponse(seq, msg.success, { scriptSource: msg.body[0].source });
        });
      }
    },
    startProfiling: {
      value: function () {
        sendEvent('setRecordingProfile', { isProfiling: false });
        return this.getProfileHeaders();
      }
    },
    stopProfiling: {
      value: function () {
        var expr;
        expr = 'process.profiler.stopProfiling("org.webkit.profiles.user-initiated.' + cpuProfileCount + '")';
        return evaluate(expr, null, function (msg) {
          var obj, objProps, profile, refs;
          sendEvent('setRecordingProfile', { isProfiling: false });
          if (msg.success) {
            refs = {};
            profile = {};
            if (msg.refs && Array.isArray(msg.refs)) {
              obj = msg.body;
              objProps = obj.properties;
              msg.refs.forEach(function (r) {
                return refs[r.handle] = r;
              });
              objProps.forEach(function (p) {
                return profile[String(p.name)] = refToObject(refs[p.ref]).description;
              });
            }
            return sendProfileHeader(parseInt(profile.uid, 10), 'CPU');
          }
        });
      }
    },
    getProfileHeaders: {
      value: function () {
        evaluate('process.profiler.profileCount()', null, function (msg1) {
          if (msg1.success)
            return function (accum$) {
              var i;
              for (var i$ = 0, length$ = function () {
                    var accum$1;
                    var accum$1;
                    accum$1 = [];
                    for (var i$1 = 0; 0 <= msg1.body.value ? i$1 <= msg1.body.value : i$1 >= msg1.body.value; 0 <= msg1.body.value ? ++i$1 : --i$1)
                      accum$1.push(i$1);
                    return accum$1;
                  }.apply(this, arguments).length; i$ < length$; ++i$) {
                i = function () {
                  var accum$1;
                  var accum$1;
                  accum$1 = [];
                  for (var i$1 = 0; 0 <= msg1.body.value ? i$1 <= msg1.body.value : i$1 >= msg1.body.value; 0 <= msg1.body.value ? ++i$1 : --i$1)
                    accum$1.push(i$1);
                  return accum$1;
                }.apply(this, arguments)[i$];
                accum$.push(evaluate('process.profiler.getProfile(' + i + ')', null, function (msg) {
                  var obj, objProps, profile, refs;
                  if (msg.success) {
                    refs = {};
                    {
                      profile = {};
                      if (msg.refs && Array.isArray(msg.refs)) {
                        obj = msg.body;
                        {
                          objProps = obj.properties;
                          msg.refs.forEach(function (r) {
                            return refs[r.handle] = r;
                          });
                        }
                        objProps.forEach(function (p) {
                          return profile[String(p.name)] = refToObject(refs[p.ref]).description;
                        });
                      }
                    }
                    return sendProfileHeader(profile.title, parseInt(profile.uid, 10), 'CPU');
                  }
                }));
              }
              return accum$;
            }.call(this, []);
        });
        return evaluate('process.profiler.snapshotCount()', null, function (msg1) {
          if (msg1.success)
            return function (accum$) {
              var i;
              for (var i$ = 0, length$ = function () {
                    var accum$1;
                    var accum$1;
                    accum$1 = [];
                    for (var i$1 = 0; 0 <= msg1.body.value ? i$1 <= msg1.body.value : i$1 >= msg1.body.value; 0 <= msg1.body.value ? ++i$1 : --i$1)
                      accum$1.push(i$1);
                    return accum$1;
                  }.apply(this, arguments).length; i$ < length$; ++i$) {
                i = function () {
                  var accum$1;
                  var accum$1;
                  accum$1 = [];
                  for (var i$1 = 0; 0 <= msg1.body.value ? i$1 <= msg1.body.value : i$1 >= msg1.body.value; 0 <= msg1.body.value ? ++i$1 : --i$1)
                    accum$1.push(i$1);
                  return accum$1;
                }.apply(this, arguments)[i$];
                accum$.push(evaluate('process.profiler.getSnapshot(' + i + ')', null, function (msg) {
                  var obj, objProps, profile, refs, title;
                  if (msg.success) {
                    refs = {};
                    profile = {};
                    if (msg.refs && Array.isArray(msg.refs)) {
                      obj = msg.body;
                      objProps = obj.properties;
                      msg.refs.forEach(function (r) {
                        return refs[r.handle] = r;
                      });
                      objProps.forEach(function (p) {
                        return profile[String(p.name)] = refToObject(refs[p.ref]).description;
                      });
                    }
                    title = profile.title === 'undefined' ? 'org.webkit.profiles.user-initiated.' + profile.ui : profile.title;
                    return sendProfileHeader(title, parseInt(profile.uid, 10), 'HEAP');
                  }
                }));
              }
              return accum$;
            }.call(this, []);
        });
      }
    },
    getProfile: {
      value: function (type, uid, seq) {
        var expr;
        expr = function () {
          switch (type) {
          case 'HEAP':
            return 'process.profiler.findSnapshot(' + uid + ').stringify()';
          case 'CPU':
            return 'process.profiler.findProfile(' + uid + ').stringify()';
          default:
            return null;
          }
        }.call(this);
        return evaluate(expr, null, function (msg) {
          return sendResponse(seq, true, {
            profile: {
              title: 'org.webkit.profiles.user-initiated.' + uid,
              uid: uid,
              typeId: type,
              head: JSON.parse(msg.body.value)
            }
          });
        });
      }
    },
    removeProfile: {
      value: function (type, uid) {
      }
    },
    clearProfiles: {
      value: function () {
      }
    },
    takeHeapSnapshot: {
      value: function () {
        return evaluate('process.profiler.takeSnapshot()', null, function (msg) {
          var obj, objProps, profile, refs;
          if (msg.success) {
            refs = {};
            profile = {};
            if (msg.refs && Array.isArray(msg.refs)) {
              obj = msg.body;
              objProps = obj.properties;
              msg.refs.forEach(function (r) {
                return refs[r.handle] = r;
              });
              objProps.forEach(function (p) {
                return profile[String(p.name)] = refToObject(refs[p.ref]).description;
              });
            }
            return sendProfileHeader('org.webkit.profiles.user-initiated.' + profile.uid, parseInt(profile.uid, 10), 'HEAP');
          }
        });
      }
    },
    join: {
      value: function (ws_connection) {
        var this$, this$1;
        conn = ws_connection;
        conn.on('message', (this$ = this, function (data) {
          return this$.handleRequest(data);
        }));
        conn.on('disconnect', (this$1 = this, function () {
          this$1.emit('ws_closed');
          return conn = null;
        }));
        return browserConnected();
      }
    },
    handleRequest: {
      value: function (data) {
        var agent, agentName, args, cache$, functionName, handlerFn, msg;
        msg = JSON.parse(data);
        if (msg.method) {
          cache$ = msg.method.split('.');
          agentName = cache$[0];
          functionName = cache$[1];
          console.log('[agents.handleRequest] ' + agentName + '#' + functionName);
          args = [];
          if (msg.params)
            args.push(msg.params);
          if (msg.id > 0)
            args.push(function (error, data) {
              data = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
              return sendResponse(msg.id, error, data);
            });
          agent = agents[agentName];
          handlerFn = agent[functionName];
          handlerFn.apply(agent, args);
        } else {
          console.log('Unknown message from frontend:', msg);
        }
        if (typeof command === 'function') {
          args = Object.keys(msg['arguments']).map(function (x) {
            return msg['arguments'][x];
          });
          if (msg.seq > 0)
            args.push(msg.seq);
          return command.apply(this, args);
        }
      }
    }
  });
};
