// Generated by CoffeeScript 1.6.1
(function() {
  var debugr, events,
    __slice = [].slice;

  events = require('events');

  debugr = require('./debugger');

  exports.create = function(debugConnection, config) {
    var FUNC_WRAP, LOOKUP_TIMEOUT, agents, breakEvent, breakpoints, browserConnected, conn, cpuProfileCount, debug, dispatchEvent, evaluate, mapCallFrames, parsedScripts, refToObject, sendBacktrace, sendEvent, sendProfileHeader, sendResponse, sourceIDs, sourceMaps, sourceUrls, wrapperObject;
    debug = null;
    conn = null;
    breakpoints = {};
    sourceIDs = {};
    sourceUrls = {};
    sourceMaps = {};
    LOOKUP_TIMEOUT = 2500;
    FUNC_WRAP = /^\(function \(exports, require, module, __filename, __dirname\) \{ ([\s\S]*)\n\}\);$/;
    cpuProfileCount = 0;
    agents = {
      Debugger: {
        enable: function(cb) {
          console.log('Debbuger#enable');
          return cb(null, true);
        },
        disable: function(cb) {
          console.log('Debbuger#disable');
          return cb(null, true);
        },
        setPauseOnExceptions: function(_arg, cb) {
          var state;
          state = _arg.state;
          console.log('Debugger#setPauseOnExceptions', arguments[0]);
          return cb(null, true);
        },
        setBreakpointsActive: function(_arg, cb) {
          var active;
          active = _arg.active;
          console.log('Debugger#setBreakpointsActive', arguments[0]);
          return cb(null, true);
        },
        removeBreakpoint: function(_arg, cb) {
          var breakpointId;
          breakpointId = _arg.breakpointId;
          return debug.request('clearbreakpoint', {
            "arguments": {
              breakpoint: breakpointId
            }
          }, function(msg) {
            var id;
            for (id in breakpoints) {
              if (breakpoints[id] === breakpointId) {
                delete breakpoints[id];
                break;
              }
            }
            return cb(null);
          });
        },
        setBreakpointByUrl: function(_arg, cb) {
          var args, bp, columnNumber, condition, enabled, lineNumber, sourceID, url;
          lineNumber = _arg.lineNumber, url = _arg.url, columnNumber = _arg.columnNumber, condition = _arg.condition;
          enabled = true;
          sourceID = sourceUrls[url];
          if (bp = breakpoints[sourceID + ':' + lineNumber]) {
            args = {
              "arguments": {
                breakpoint: bp.breakpointId,
                enabled: enabled,
                condition: condition
              }
            };
            return debug.request('changebreakpoint', args, function(msg) {
              bp.enabled = enabled;
              bp.condition = condition;
              return cb(null, bp.breakpointId, bp.locations);
            });
          } else {
            args = {
              type: 'scriptId',
              target: sourceID,
              line: lineNumber - 1,
              enabled: enabled,
              condition: condition
            };
            return debug.request('setbreakpoint', {
              "arguments": args
            }, function(msg) {
              var b;
              if (msg.success) {
                b = msg.body;
                bp = breakpoints[b.script_id + ':' + (b.line + 1)] = {
                  sourceID: b.script_id,
                  url: sourceIDs[b.script_id].url,
                  line: b.line + 1,
                  breakpointId: b.breakpoint.toString(),
                  locations: b.actual_locations.map(function(l) {
                    return {
                      scriptId: l.script_id.toString(),
                      lineNumber: l.line,
                      columnNumber: l.column
                    };
                  }),
                  enabled: enabled,
                  condition: condition
                };
                return cb(null, bp.breakpointId, bp.locations);
              }
            });
          }
        },
        pause: function(cb) {
          console.log('Debugger#pause');
          return debug.request('suspend', {}, function(msg) {
            return breakEvent();
          });
        },
        resume: function(cb) {
          console.log('Debugger#resume');
          return debug.request('continue', {}, function(msg) {
            return cb(null, true);
          });
        },
        stepOver: function(cb) {
          return debug.request('continue', {
            "arguments": {
              stepaction: 'next'
            }
          }, function(msg) {
            return cb(null, true);
          });
        },
        stepInto: function() {
          return debug.request('continue', {
            "arguments": {
              stepaction: 'in'
            }
          }, function(msg) {
            return cb(null, true);
          });
        },
        stepOutOfFunction: function() {
          return debug.request('continue', {
            "arguments": {
              stepaction: 'out'
            }
          }, function(msg) {
            return cb(null, true);
          });
        },
        getScriptSource: function(_arg, cb) {
          var args, scriptId;
          scriptId = _arg.scriptId;
          args = {
            "arguments": {
              includeSource: true,
              types: 4,
              ids: [scriptId]
            }
          };
          return debug.request('scripts', args, function(msg) {
            return cb(null, msg.body[0].source);
          });
        }
      },
      Console: {
        enable: function(cb) {
          console.log('Console#enable');
          return cb(null, true);
        }
      },
      Runtime: {
        getProperties: function(_arg, cb) {
          var frame, handle, objectId, ownProperties, ref, scope, timeout, _ref;
          objectId = _arg.objectId, ownProperties = _arg.ownProperties;
          _ref = objectId.split(':'), frame = _ref[0], scope = _ref[1], ref = _ref[2];
          if (ref === 'backtrace') {
            return debug.request('scope', {
              "arguments": {
                number: scope,
                frameNumber: frame,
                inlineRefs: true
              }
            }, function(msg) {
              var refs;
              if (msg.success) {
                refs = {};
                if (msg.refs && Array.isArray(msg.refs)) {
                  msg.refs.forEach(function(r) {
                    return refs[r.handle] = r;
                  });
                }
                return cb(null, msg.body.object.properties.map(function(p) {
                  var r;
                  r = refs[p.value.ref];
                  return {
                    name: p.name,
                    value: refToObject(r)
                  };
                }));
              }
            });
          } else {
            handle = parseInt(ref, 10);
            timeout = setTimeout(function() {
              var seq;
              cb(null, [
                {
                  name: 'sorry',
                  value: wrapperObject('string', 'lookup timed out', false, 0, 0, 0)
                }
              ]);
              return seq = 0;
            }, LOOKUP_TIMEOUT);
            return debug.request('lookup', {
              "arguments": {
                handles: [handle],
                includeSource: false
              }
            }, function(msg) {
              var obj, objProps, props, proto, r, refs, _i, _len, _ref1;
              clearTimeout(timeout);
              if (msg.success) {
                refs = {};
                props = [];
                if (msg.refs && Array.isArray(msg.refs)) {
                  obj = msg.body[handle];
                  objProps = obj.properties;
                  proto = obj.protoObject;
                  _ref1 = msg.refs;
                  for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                    r = _ref1[_i];
                    refs[r.handle] = r;
                  }
                  props = objProps.map(function(p) {
                    r = refs[p.ref];
                    return {
                      name: String(p.name),
                      value: refToObject(r)
                    };
                  });
                  if (proto) {
                    props.push({
                      name: '__proto__',
                      value: refToObject(refs[proto.ref])
                    });
                  }
                }
                return cb(null, props);
              }
            });
          }
        }
      }
    };
    wrapperObject = function(type, description, hasChildren, frame, scope, ref) {
      return {
        type: type,
        description: description,
        hasChildren: hasChildren,
        objectId: "" + frame + ":" + scope + ":" + ref
      };
    };
    refToObject = function(ref) {
      var desc, kids, name, _ref, _ref1, _ref2;
      desc = '';
      name = null;
      kids = ref.properties ? ref.properties.length : false;
      switch (ref.type) {
        case 'object':
          name = /#<an?\s(\w+)>/.exec(ref.text);
          if ((name != null ? name.length : void 0) > 1) {
            desc = name[1];
            if (desc === 'Array') {
              desc += '[' + (ref.properties.length - 1) + ']';
            } else if (desc === 'Buffer') {
              desc += '[' + (ref.properties.length - 4) + ']';
            }
          } else {
            desc = (_ref = ref.className) != null ? _ref : 'Object';
          }
          break;
        case 'function':
          desc = (_ref1 = ref.text) != null ? _ref1 : 'function()';
          break;
        default:
          desc = (_ref2 = ref.text) != null ? _ref2 : '';
      }
      if (desc.length > 100) {
        desc = desc.substring(0, 100) + '\u2026';
      }
      return wrapperObject(ref.type, desc, kids, 0, 0, ref.handle);
    };
    mapCallFrames = function(bt) {
      if (bt.body.totalFrames > 0) {
        return bt.body.frames.map(function(frame) {
          console.log(frame);
          return {
            id: frame.index,
            functionName: frame.func.inferredName,
            type: 'function',
            worldId: 1,
            location: {
              scriptId: frame.func.scriptId.toString(),
              lineNumber: frame.line + 1,
              columnNumber: frame.column
            },
            scopeChain: frame.scopes.map(function(scope) {
              return {
                object: wrapperObject('object', frame.receiver.className, true, frame.index, scope.index, frame.receiver.ref),
                objectId: frame.index + ':' + scope.index + ':backtrace',
                type: (function() {
                  switch (scope.type) {
                    case 1:
                      return 'local';
                    case 2:
                      return 'with';
                    case 3:
                      return 'closure';
                    case 4:
                      return 'global';
                  }
                })()
              };
            })
          };
        });
      } else {
        return [
          {
            type: 'program',
            location: {
              scriptId: 'internal'
            },
            line: 0,
            id: 0,
            worldId: 1,
            scopeChain: []
          }
        ];
      }
    };
    evaluate = function(expr, frame, andThen) {
      var args;
      args = {
        expression: expr,
        disable_break: true,
        global: true,
        maxStringLength: 100000
      };
      if (frame != null) {
        args.frame = frame;
        args.global = false;
      }
      return debug.request('evaluate', {
        "arguments": args
      }, andThen);
    };
    sendBacktrace = function() {
      return debug.request('backtrace', {
        "arguments": {
          inlineRefs: true
        }
      }, function(msg) {
        var callFrames;
        callFrames = mapCallFrames(msg);
        return dispatchEvent('Debugger.paused', {
          details: callFrames
        });
      });
    };
    breakEvent = function(obj) {
      var args, scriptId, source;
      scriptId = obj != null ? obj.body.script.id : null;
      if (scriptId != null) {
        source = sourceIDs[scriptId];
      }
      if (source == null) {
        args = {
          "arguments": {
            includeSource: true,
            types: 4,
            ids: scriptId != null ? [obj.body.script.id] : void 0
          }
        };
        debug.request('scripts', args, parsedScripts);
      } else if (source != null ? source.hidden : void 0) {
        debug.request('continue', {
          "arguments": {
            stepaction: 'out'
          }
        });
        return;
      }
      return sendBacktrace();
    };
    parsedScripts = function(msg) {
      var paths, scripts, shorten;
      scripts = msg.body.map(function(s) {
        return {
          scriptId: String(s.id),
          url: s.name,
          data: s.source,
          startLine: s.lineOffset,
          path: String(s.name).split('/'),
          isContentScript: false
        };
      });
      scripts.sort(function(a, b) {
        return a.path.length - b.path.length;
      });
      paths = [];
      shorten = function(s) {
        var i, p, _i, _ref;
        for (i = _i = _ref = s.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
          p = s.slice(i).join('/');
          if (paths.indexOf(p) === -1) {
            paths.push(p);
            return p;
          }
        }
        return s.join('/');
      };
      return scripts.forEach(function(s) {
        var hidden, item, sourceMapMatch;
        hidden = config.hidden && config.hidden.some(function(r) {
          return r.test(s.url);
        });
        sourceMapMatch = s.data.match(/\s\/\/@ sourceMappingURL=data:application\/json;base64,(.*)/);
        s.sourceMapURL = null;
        if (sourceMapMatch) {
          s.sourceMapURL = "/_sourcemap/" + s.scriptId;
          sourceMaps[s.scriptId.toString()] = JSON.parse((new Buffer(sourceMapMatch[1], 'base64')).toString('utf8'));
        }
        item = {
          hidden: hidden,
          path: s.url
        };
        s.url = s.path.join('/');
        item.url = s.url;
        sourceIDs[s.scriptId] = item;
        sourceUrls[item.url] = s.scriptId;
        delete s.path;
        if (!hidden) {
          return dispatchEvent('Debugger.scriptParsed', s);
        }
      });
    };
    sendProfileHeader = function(title, uid, type) {
      return sendEvent('addProfileHeader', {
        header: {
          title: title,
          uid: uid,
          typeId: type
        }
      });
    };
    sendEvent = function(name, data) {
      if (data == null) {
        data = {};
      }
      if (conn) {
        return conn.send(JSON.stringify({
          type: 'event',
          event: name,
          data: data
        }));
      }
    };
    dispatchEvent = function(method, params) {
      if (params == null) {
        params = {};
      }
      if (conn) {
        return conn.send(JSON.stringify({
          method: method,
          params: params
        }));
      } else {
        return console.log('Could not send: ', method, params);
      }
    };
    sendResponse = function(seq, success, data) {
      if (data == null) {
        data = {};
      }
      if (conn) {
        return conn.send(JSON.stringify({
          id: seq,
          error: null,
          result: data
        }));
      }
    };
    browserConnected = function() {
      var args;
      args = {
        "arguments": {
          includeSource: true,
          types: 4
        }
      };
      console.log('[debug.request] scripts', args);
      return debug.request('scripts', args, function(msg) {
        console.log('[debug.response] scripts');
        parsedScripts(msg);
        return debug.request('listbreakpoints', {}, function(msg) {
          msg.body.breakpoints.forEach(function(bp) {
            var data;
            if (bp.type === 'scriptId') {
              data = {
                sourceID: bp.script_id,
                url: sourceIDs[bp.script_id].url,
                line: bp.line + 1,
                enabled: bp.active,
                condition: bp.condition,
                number: bp.number
              };
              breakpoints[bp.script_id + ':' + (bp.line + 1)] = data;
              return sendEvent('restoredBreakpoint', data);
            }
          });
          if (!msg.running) {
            return sendBacktrace();
          }
        });
      });
    };
    return Object.create(events.EventEmitter.prototype, {
      getSourceMap: {
        value: function(id) {
          return sourceMaps[id];
        }
      },
      attach: {
        value: function() {
          var _this = this;
          debug = debugr.attachDebugger(debugConnection);
          debug.on('break', breakEvent);
          debug.on('close', function() {
            debug = {
              request: function() {
                return console.error('debugger not connected');
              }
            };
            sendEvent('debuggerWasDisabled');
            return _this.close();
          });
          debug.on('connect', function() {
            return browserConnected();
          });
          debug.on('exception', function(msg) {
            return breakEvent(msg);
          });
          return debug.on('error', function(e) {
            var data, err;
            sendEvent('showPanel', {
              name: 'console'
            });
            err = e.toString();
            if (err.match(/ECONNREFUSED/)) {
              err += '\nIs node running with --debug?';
            }
            data = {
              messageObj: {
                source: 3,
                type: 0,
                level: 3,
                line: 0,
                url: '',
                groupLevel: 7,
                repeatCount: 1,
                message: err
              }
            };
            return sendEvent('addConsoleMessage', data);
          });
        }
      },
      close: {
        value: function() {
          if (debug && debug.connected) {
            debug.close();
          }
          return this.emit('close');
        }
      },
      enableDebugger: {
        value: function(always) {
          return this.attach();
        }
      },
      dispatchOnInjectedScript: {
        value: function(injectedScriptId, methodName, argString, seq) {
          var args, data, evalResponse, expr, frame, handle, objectId, ref, scope, timeout, tokens;
          args = JSON.parse(argString);
          if (methodName === 'getProperties') {
            objectId = args[0];
            tokens = objectId.split(':');
            frame = parseInt(tokens[0], 10);
            scope = parseInt(tokens[1], 10);
            ref = tokens[2];
            if (ref === 'backtrace') {
              return debug.request('scope', {
                "arguments": {
                  number: scope,
                  frameNumber: frame,
                  inlineRefs: true
                }
              }, function(msg) {
                var props, refs;
                if (msg.success) {
                  refs = {};
                  if (msg.refs && Array.isArray(msg.refs)) {
                    msg.refs.forEach(function(r) {
                      return refs[r.handle] = r;
                    });
                  }
                  props = msg.body.object.properties.map(function(p) {
                    var r;
                    r = refs[p.value.ref];
                    return {
                      name: p.name,
                      value: refToObject(r)
                    };
                  });
                  return sendResponse(seq, true, {
                    result: props
                  });
                }
              });
            } else {
              handle = parseInt(ref, 10);
              timeout = setTimeout(function() {
                sendResponse(seq, true, {
                  result: [
                    {
                      name: 'sorry',
                      value: wrapperObject('string', 'lookup timed out', false, 0, 0, 0)
                    }
                  ]
                });
                return seq = 0;
              }, LOOKUP_TIMEOUT);
              return debug.request('lookup', {
                "arguments": {
                  handles: [handle],
                  includeSource: false
                }
              }, function(msg) {
                var obj, objProps, props, proto, refs;
                clearTimeout(timeout);
                if (msg.success && seq !== 0) {
                  refs = {};
                  props = [];
                  if (msg.refs && Array.isArray(msg.refs)) {
                    obj = msg.body[handle];
                    objProps = obj.properties;
                    proto = obj.protoObject;
                    msg.refs.forEach(function(r) {
                      return refs[r.handle] = r;
                    });
                    props = objProps.map(function(p) {
                      var r;
                      r = refs[p.ref];
                      return {
                        name: String(p.name),
                        value: refToObject(r)
                      };
                    });
                    if (proto) {
                      props.push({
                        name: '__proto__',
                        value: refToObject(refs[proto.ref])
                      });
                    }
                  }
                  return sendResponse(seq, true, {
                    result: props
                  });
                }
              });
            }
          } else if (methodName === 'getCompletions') {
            expr = args[0];
            data = {
              result: {},
              isException: false
            };
            if (expr === '') {
              sendResponse(seq, true, data);
              return;
            }
            return evaluate(expr, args[2], function(msg) {
              if (msg.success && msg.body.properties && msg.body.properties.length < 256) {
                msg.body.properties.forEach(function(p) {
                  return data.result[p.name] = true;
                });
              }
              return sendResponse(seq, true, data);
            });
          } else {
            evalResponse = function(msg) {
              if (msg.success) {
                return sendResponse(seq, true, {
                  result: refToObject(msg.body),
                  isException: false
                });
              } else {
                return sendResponse(seq, true, {
                  result: {
                    type: 'error',
                    description: msg.message
                  },
                  isException: false
                });
              }
            };
            if (methodName === 'evaluateInCallFrame') {
              return evaluate(args[1], args[0], evalResponse);
            } else if (methodName === 'evaluate') {
              return evaluate(args[0], null, evalResponse);
            }
          }
        }
      },
      disableDebugger: {
        value: function(always) {
          if (debug && debug.connected) {
            return debug.close();
          }
        }
      },
      populateScriptObjects: {
        value: function(seq) {
          return sendResponse(seq, true, {});
        }
      },
      getInspectorState: {
        value: function(seq) {
          return sendResponse(seq, true, {
            state: {
              monitoringXHREnabled: false,
              resourceTrackingEnabled: false
            }
          });
        }
      },
      getResourceContent: {
        value: function(identifier, encode) {}
      },
      enableProfiler: {
        value: function(always) {
          if (debug && debug.connected) {
            return evaluate('process.profiler !== undefined', null, function(msg) {
              if (msg.body.value) {
                return sendEvent('profilerWasEnabled');
              } else {
                sendEvent('showPanel', {
                  name: 'console'
                });
                return sendEvent('addConsoleMessage', {
                  messageObj: {
                    source: 3,
                    type: 0,
                    level: 2,
                    line: 0,
                    url: '',
                    repeatCount: 1,
                    message: 'you must require("v8-profiler") to use the profiler'
                  }
                });
              }
            });
          } else {
            sendEvent('showPanel', {
              name: 'console'
            });
            return sendEvent('addConsoleMessage', {
              messageObj: {
                source: 3,
                type: 0,
                level: 2,
                line: 0,
                url: '',
                repeatCount: 1,
                message: 'not connected to node'
              }
            });
          }
        }
      },
      disableProfiler: {
        value: function(always) {}
      },
      clearConsoleMessages: {
        value: function() {
          return sendEvent('consoleMessagesCleared');
        }
      },
      setBreakpoint: {
        value: function(sourceID, lineNumber, enabled, condition, seq) {
          var bp, handleResponse;
          bp = breakpoints[sourceID + ':' + lineNumber];
          handleResponse = function(msg) {
            var b, data;
            if (msg.success) {
              b = msg.body;
              breakpoints[b.script_id + ':' + (b.line + 1)] = {
                sourceID: b.script_id,
                url: sourceIDs[b.script_id].url,
                line: b.line + 1,
                enabled: enabled,
                condition: condition,
                number: b.breakpoint
              };
              b.breakpoint;
              data = {
                success: true,
                actualLineNumber: b.line + 1
              };
              return sendResponse(seq, true, data);
            }
          };
          if (bp) {
            return debug.request('changebreakpoint', {
              "arguments": {
                breakpoint: bp.number,
                enabled: enabled,
                condition: condition
              }
            }, function(msg) {
              var data;
              bp.enabled = enabled;
              bp.condition = condition;
              data = {
                success: true,
                actualLineNumber: lineNumber
              };
              return sendResponse(seq, true, data);
            });
          } else {
            return debug.request('setbreakpoint', {
              "arguments": {
                type: 'scriptId',
                target: sourceID,
                line: lineNumber - 1,
                enabled: enabled,
                condition: condition
              }
            }, handleResponse);
          }
        }
      },
      removeBreakpoint: {
        value: function(sourceID, lineNumber) {
          var id;
          id = sourceID + ':' + lineNumber;
          return debug.request('clearbreakpoint', {
            "arguments": {
              breakpoint: breakpoints[id].number
            }
          }, function(msg) {
            if (msg.success) {
              return delete breakpoints[id];
            }
          });
        }
      },
      activateBreakpoints: {
        value: function() {
          return Object.keys(breakpoints).forEach(function(key) {
            var bp;
            bp = breakpoints[key];
            return debug.request('changebreakpoint', {
              "arguments": {
                breakpoint: bp.number,
                condition: bp.condition,
                enabled: true
              }
            }, function(msg) {
              if (msg.success) {
                bp.enabled = true;
                return sendEvent('restoredBreakpoint', bp);
              }
            });
          });
        }
      },
      deactivateBreakpoints: {
        value: function(injectedScriptId, objectGroup) {
          return Object.keys(breakpoints).forEach(function(key) {
            var bp;
            bp = breakpoints[key];
            return debug.request('changebreakpoint', {
              "arguments": {
                breakpoint: bp.number,
                condition: bp.condition,
                enabled: false
              }
            }, function(msg) {
              if (msg.success) {
                bp.enabled = false;
                return sendEvent('restoredBreakpoint', bp);
              }
            });
          });
        }
      },
      pause: {
        value: function() {
          return debug.request('suspend', {}, function(msg) {
            if (!msg.running) {
              return sendBacktrace();
            }
          });
        }
      },
      resume: {
        value: function() {
          debug.request('continue');
          return sendEvent('resumedScript');
        }
      },
      stepOverStatement: {
        value: function() {
          debug.request('continue', {
            "arguments": {
              stepaction: 'next'
            }
          });
          return sendEvent('resumedScript');
        }
      },
      stepIntoStatement: {
        value: function() {
          debug.request('continue', {
            "arguments": {
              stepaction: 'in'
            }
          });
          return sendEvent('resumedScript');
        }
      },
      stepOutOfFunction: {
        value: function() {
          debug.request('continue', {
            "arguments": {
              stepaction: 'out'
            }
          });
          return sendEvent('resumedScript');
        }
      },
      setPauseOnExceptionsState: {
        value: function(state, seq) {
          var params;
          params = {
            "arguments": {
              flags: [
                {
                  name: 'breakOnCaughtException',
                  value: state === 1
                }
              ]
            }
          };
          return debug.request('flags', params, function(msg) {
            var value;
            value = 0;
            if (msg.success) {
              if (msg.body.flags.some(function(x) {
                return x.name === 'breakOnCaughtException' && x.value;
              })) {
                value = 1;
              }
              return sendResponse(seq, true, {
                pauseOnExceptionState: value
              });
            }
          });
        }
      },
      editScriptSource: {
        value: function(sourceID, newContent, seq) {
          var args;
          args = {
            script_id: sourceID,
            preview_only: false,
            new_source: newContent
          };
          return debug.request('changelive', {
            "arguments": args
          }, function(msg) {
            var fs, match, newSource;
            sendResponse(seq, true, {
              success: msg.success,
              newBodyOrErrorMessage: msg.message || newContent
            });
            if (msg.success && config.saveLiveEdit) {
              fs = require('fs');
              match = FUNC_WRAP.exec(newContent);
              newSource = null;
              if (match && sourceIDs[sourceID] && sourceIDs[sourceID].path) {
                newSource = match[1];
                return fs.writeFile(sourceIDs[sourceID].path, newSource, function(e) {
                  var data, err;
                  if (e) {
                    err = e.toString();
                    data = {
                      messageObj: {
                        source: 3,
                        type: 0,
                        level: 3,
                        line: 0,
                        url: '',
                        groupLevel: 7,
                        repeatCount: 1,
                        message: err
                      }
                    };
                    return sendEvent('addConsoleMessage', data);
                  }
                });
              }
            }
          });
        }
      },
      getScriptSource: {
        value: function(sourceID, seq) {
          var args;
          args = {
            "arguments": {
              includeSource: true,
              types: 4,
              ids: [sourceID]
            }
          };
          return debug.request('scripts', args, function(msg) {
            return sendResponse(seq, msg.success, {
              scriptSource: msg.body[0].source
            });
          });
        }
      },
      startProfiling: {
        value: function() {
          /*
          HACK
           * changed the behavior here since using eval doesn't profile the
           * correct context. Using as a 'refresh' in the mean time
           * Remove this hack once we can trigger a profile in the proper context
          */
          sendEvent('setRecordingProfile', {
            isProfiling: false
          });
          return this.getProfileHeaders();
        }
      },
      stopProfiling: {
        value: function() {
          return evaluate('process.profiler.stopProfiling("org.webkit.profiles.user-initiated.' + cpuProfileCount + '")', null, function(msg) {
            var obj, objProps, profile, refs;
            sendEvent('setRecordingProfile', {
              isProfiling: false
            });
            if (msg.success) {
              refs = {};
              profile = {};
              if (msg.refs && Array.isArray(msg.refs)) {
                obj = msg.body;
                objProps = obj.properties;
                msg.refs.forEach(function(r) {
                  return refs[r.handle] = r;
                });
                objProps.forEach(function(p) {
                  return profile[String(p.name)] = refToObject(refs[p.ref]).description;
                });
              }
              return sendProfileHeader(parseInt(profile.uid, 10), 'CPU');
            }
          });
        }
      },
      getProfileHeaders: {
        value: function() {
          evaluate('process.profiler.profileCount()', null, function(msg1) {
            var i, _i, _ref, _results;
            if (msg1.success) {
              _results = [];
              for (i = _i = 0, _ref = msg1.body.value; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
                _results.push(evaluate('process.profiler.getProfile(' + i + ')', null, function(msg) {
                  var obj, objProps, profile, refs;
                  if (msg.success) {
                    refs = {};
                    profile = {};
                    if (msg.refs && Array.isArray(msg.refs)) {
                      obj = msg.body;
                      objProps = obj.properties;
                      msg.refs.forEach(function(r) {
                        return refs[r.handle] = r;
                      });
                      objProps.forEach(function(p) {
                        return profile[String(p.name)] = refToObject(refs[p.ref]).description;
                      });
                    }
                    return sendProfileHeader(profile.title, parseInt(profile.uid, 10), 'CPU');
                  }
                }));
              }
              return _results;
            }
          });
          return evaluate('process.profiler.snapshotCount()', null, function(msg1) {
            var i, _i, _ref, _results;
            if (msg1.success) {
              _results = [];
              for (i = _i = 0, _ref = msg1.body.value; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
                _results.push(evaluate('process.profiler.getSnapshot(' + i + ')', null, function(msg) {
                  var obj, objProps, profile, refs, title;
                  if (msg.success) {
                    refs = {};
                    profile = {};
                    if (msg.refs && Array.isArray(msg.refs)) {
                      obj = msg.body;
                      objProps = obj.properties;
                      msg.refs.forEach(function(r) {
                        return refs[r.handle] = r;
                      });
                      objProps.forEach(function(p) {
                        return profile[String(p.name)] = refToObject(refs[p.ref]).description;
                      });
                    }
                    title = profile.title === 'undefined' ? 'org.webkit.profiles.user-initiated.' + profile.ui : profile.title;
                    return sendProfileHeader(title, parseInt(profile.uid, 10), 'HEAP');
                  }
                }));
              }
              return _results;
            }
          });
        }
      },
      getProfile: {
        value: function(type, uid, seq) {
          var expr;
          expr = (function() {
            switch (type) {
              case 'HEAP':
                return 'process.profiler.findSnapshot(' + uid + ').stringify()';
              case 'CPU':
                return 'process.profiler.findProfile(' + uid + ').stringify()';
              default:
                return null;
            }
          })();
          return evaluate(expr, null, function(msg) {
            return sendResponse(seq, true, {
              profile: {
                title: 'org.webkit.profiles.user-initiated.' + uid,
                uid: uid,
                typeId: type,
                head: JSON.parse(msg.body.value)
              }
            });
          });
        }
      },
      removeProfile: {
        value: function(type, uid) {}
      },
      clearProfiles: {
        value: function() {}
      },
      takeHeapSnapshot: {
        value: function() {
          return evaluate('process.profiler.takeSnapshot()', null, function(msg) {
            var obj, objProps, profile, refs;
            if (msg.success) {
              refs = {};
              profile = {};
              if (msg.refs && Array.isArray(msg.refs)) {
                obj = msg.body;
                objProps = obj.properties;
                msg.refs.forEach(function(r) {
                  return refs[r.handle] = r;
                });
                objProps.forEach(function(p) {
                  return profile[String(p.name)] = refToObject(refs[p.ref]).description;
                });
              }
              return sendProfileHeader('org.webkit.profiles.user-initiated.' + profile.uid, parseInt(profile.uid, 10), 'HEAP');
            }
          });
        }
      },
      join: {
        value: function(ws_connection) {
          var _this = this;
          conn = ws_connection;
          conn.on('message', function(data) {
            return _this.handleRequest(data);
          });
          conn.on('disconnect', function() {
            _this.emit('ws_closed');
            return conn = null;
          });
          return browserConnected();
        }
      },
      handleRequest: {
        value: function(data) {
          var agent, agentName, args, functionName, handlerFn, msg, _ref;
          msg = JSON.parse(data);
          if (msg.method) {
            _ref = msg.method.split('.'), agentName = _ref[0], functionName = _ref[1];
            console.log("[agents.handleRequest] " + agentName + "#" + functionName);
            args = [];
            if (msg.params) {
              args.push(msg.params);
            }
            if (msg.id > 0) {
              args.push(function() {
                var data, error;
                error = arguments[0], data = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
                return sendResponse(msg.id, error, data);
              });
            }
            agent = agents[agentName];
            handlerFn = agent[functionName];
            handlerFn.apply(agent, args);
          } else {
            console.log('Unknown message from frontend:', msg);
          }
          if (typeof command === 'function') {
            args = Object.keys(msg["arguments"]).map(function(x) {
              return msg["arguments"][x];
            });
            if (msg.seq > 0) {
              args.push(msg.seq);
            }
            return command.apply(this, args);
          }
        }
      }
    });
  };

}).call(this);
