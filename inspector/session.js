// Generated by CoffeeScript 1.6.1
var debugr, events;

events = require('events');

debugr = require('./debugger');

exports.create = function(debuggerPort, config) {
  var FUNC_WRAP, LOOKUP_TIMEOUT, breakEvent, breakpoints, browserConnected, callFrames, conn, cpuProfileCount, debug, evaluate, parsedScripts, refToObject, sendBacktrace, sendEvent, sendPing, sendProfileHeader, sendResponse, sourceIDs, wrapperObject;
  debug = null;
  conn = null;
  breakpoints = {};
  sourceIDs = {};
  LOOKUP_TIMEOUT = 2500;
  FUNC_WRAP = /^\(function \(exports, require, module, __filename, __dirname\) \{ ([\s\S]*)\n\}\);$/;
  cpuProfileCount = 0;
  wrapperObject = function(type, description, hasChildren, frame, scope, ref) {
    return {
      type: type,
      description: description,
      hasChildren: hasChildren,
      objectId: "" + frame + ":" + scope + ":" + ref
    };
  };
  refToObject = function(ref) {
    var desc, kids, name, _ref, _ref1, _ref2;
    desc = '';
    name = null;
    kids = ref.properties ? ref.properties.length : false;
    switch (ref.type) {
      case 'object':
        name = /#<an?\s(\w+)>/.exec(ref.text);
        if ((name != null ? name.length : void 0) > 1) {
          desc = name[1];
          if (desc === 'Array') {
            desc += '[' + (ref.properties.length - 1) + ']';
          } else if (desc === 'Buffer') {
            desc += '[' + (ref.properties.length - 4) + ']';
          }
        } else {
          desc = (_ref = ref.className) != null ? _ref : 'Object';
        }
        break;
      case 'function':
        desc = (_ref1 = ref.text) != null ? _ref1 : 'function()';
        break;
      default:
        desc = (_ref2 = ref.text) != null ? _ref2 : '';
    }
    if (desc.length > 100) {
      desc = desc.substring(0, 100) + '\u2026';
    }
    return wrapperObject(ref.type, desc, kids, 0, 0, ref.handle);
  };
  callFrames = function(bt) {
    if (bt.body.totalFrames > 0) {
      bt.body.frames.map(function(frame) {
        return {
          type: 'function',
          functionName: frame.func.inferredName,
          sourceID: frame.func.scriptId,
          line: frame.line + 1,
          id: frame.index,
          worldId: 1,
          scopeChain: frame.scopes.map(function(scope) {
            var c;
            c = (function() {
              switch (scope.type) {
                case 1:
                  return {
                    isLocal: true,
                    thisObject: wrapperObject('object', frame.receiver.className, true, frame.index, scope.index, frame.receiver.ref)
                  };
                case 2:
                  return {
                    isWithBlock: true
                  };
                case 3:
                  return {
                    isClosure: true
                  };
                case 4:
                  return {
                    isElement: true
                  };
                default:
                  return {};
              }
            })();
            c.objectId = frame.index + ':' + scope.index + ':backtrace';
            return c;
          })
        };
      });
    }
    return [
      {
        type: 'program',
        sourceID: 'internal',
        line: 0,
        id: 0,
        worldId: 1,
        scopeChain: []
      }
    ];
  };
  evaluate = function(expr, frame, andThen) {
    var args;
    args = {
      expression: expr,
      disable_break: true,
      global: true,
      maxStringLength: 100000
    };
    if (frame != null) {
      args.frame = frame;
      args.global = false;
    }
    return debug.request('evaluate', {
      "arguments": args
    }, andThen);
  };
  sendBacktrace = function() {
    return debug.request('backtrace', {
      "arguments": {
        inlineRefs: true
      }
    }, function(msg) {
      return sendEvent('pausedScript', {
        details: {
          callFrames: callFrames(msg)
        }
      });
    });
  };
  breakEvent = function(obj) {
    var args, data, source;
    data = args = {};
    source = sourceIDs[obj.body.script.id];
    if (source) {
      args = {
        "arguments": {
          includeSource: true,
          types: 4,
          ids: [obj.body.script.id]
        }
      };
      debug.request('scripts', args, parsedScripts);
    } else if (source.hidden) {
      debug.request('continue', {
        "arguments": {
          stepaction: 'out'
        }
      });
      return;
    }
    return sendBacktrace();
  };
  parsedScripts = function(msg) {
    var paths, scripts, shorten;
    scripts = msg.body.map(function(s) {
      return {
        sourceID: String(s.id),
        url: s.name,
        data: s.source,
        firstLine: s.lineOffset,
        scriptWorldType: 0,
        path: String(s.name).split('/')
      };
    });
    scripts.sort(function(a, b) {
      return a.path.length - b.path.length;
    });
    paths = [];
    shorten = function(s) {
      var i, p, _i, _ref;
      for (i = _i = _ref = s.length - 1; _ref <= 0 ? _i <= 0 : _i >= 0; i = _ref <= 0 ? ++_i : --_i) {
        p = s.slice(i).join('/');
        if (paths.indexOf(p) === -1) {
          paths.push(p);
          return p;
        }
      }
      return s.join('/');
    };
    return scripts.forEach(function(s) {
      var hidden, item;
      hidden = config.hidden && config.hidden.some(function(r) {
        return r.test(s.url);
      });
      item = {
        hidden: hidden,
        path: s.url
      };
      if (s.path.length > 1) {
        s.url = shorten(s.path);
      }
      item.url = s.url;
      sourceIDs[s.sourceID] = item;
      delete s.path;
      if (!hidden) {
        return sendEvent('parsedScriptSource', s);
      }
    });
  };
  sendProfileHeader = function(title, uid, type) {
    return sendEvent('addProfileHeader', {
      header: {
        title: title,
        uid: uid,
        typeId: type
      }
    });
  };
  sendEvent = function(name, data) {
    if (data == null) {
      data = {};
    }
    if (conn) {
      return conn.send(JSON.stringify({
        type: 'event',
        event: name,
        data: data
      }));
    }
  };
  sendResponse = function(seq, success, data) {
    if (data == null) {
      data = {};
    }
    if (conn) {
      return conn.send(JSON.stringify({
        seq: seq,
        success: success,
        data: data
      }));
    }
  };
  sendPing = function() {
    if (conn) {
      conn.send('ping');
      return setTimeout(sendPing, 30000);
    }
  };
  browserConnected = function() {
    var args;
    sendEvent('debuggerWasEnabled');
    sendPing();
    args = {
      "arguments": {
        includeSource: true,
        types: 4
      }
    };
    return debug.request('scripts', args, function(msg) {
      parsedScripts(msg);
      return debug.request('listbreakpoints', {}, function(msg) {
        msg.body.breakpoints.forEach(function(bp) {
          var data;
          if (bp.type === 'scriptId') {
            data = {
              sourceID: bp.script_id,
              url: sourceIDs[bp.script_id].url,
              line: bp.line + 1,
              enabled: bp.active,
              condition: bp.condition,
              number: bp.number
            };
            breakpoints[bp.script_id + ':' + (bp.line + 1)] = data;
            return sendEvent('restoredBreakpoint', data);
          }
        });
        if (!msg.running) {
          return sendBacktrace();
        }
      });
    });
  };
  return Object.create(events.EventEmitter.prototype, {
    attach: {
      value: function() {
        var _this = this;
        debug = debugr.attachDebugger(debuggerPort);
        debug.on('break', breakEvent);
        debug.on('close', function() {
          debug = {
            request: function() {
              return console.error('debugger not connected');
            }
          };
          sendEvent('debuggerWasDisabled');
          return _this.close();
        });
        debug.on('connect', function() {
          return browserConnected();
        });
        debug.on('exception', function(msg) {
          return breakEvent(msg);
        });
        return debug.on('error', function(e) {
          var data, err;
          sendEvent('showPanel', {
            name: 'console'
          });
          err = e.toString();
          if (err.match(/ECONNREFUSED/)) {
            err += '\nIs node running with --debug port ' + debuggerPort + '?';
          }
          data = {
            messageObj: {
              source: 3,
              type: 0,
              level: 3,
              line: 0,
              url: '',
              groupLevel: 7,
              repeatCount: 1,
              message: err
            }
          };
          return sendEvent('addConsoleMessage', data);
        });
      }
    },
    close: {
      value: function() {
        if (debug && debug.connected) {
          debug.close();
        }
        return this.emit('close');
      }
    },
    enableDebugger: {
      value: function(always) {
        return this.attach();
      }
    },
    dispatchOnInjectedScript: {
      value: function(injectedScriptId, methodName, argString, seq) {
        var args, data, evalResponse, expr, frame, handle, objectId, ref, scope, timeout, tokens;
        args = JSON.parse(argString);
        if (methodName === 'getProperties') {
          objectId = args[0];
          tokens = objectId.split(':');
          frame = parseInt(tokens[0], 10);
          scope = parseInt(tokens[1], 10);
          ref = tokens[2];
          if (ref === 'backtrace') {
            return debug.request('scope', {
              "arguments": {
                number: scope,
                frameNumber: frame,
                inlineRefs: true
              }
            }, function(msg) {
              var props, refs;
              if (msg.success) {
                refs = {};
                if (msg.refs && Array.isArray(msg.refs)) {
                  msg.refs.forEach(function(r) {
                    return refs[r.handle] = r;
                  });
                }
                props = msg.body.object.properties.map(function(p) {
                  var r;
                  r = refs[p.value.ref];
                  return {
                    name: p.name,
                    value: refToObject(r)
                  };
                });
                return sendResponse(seq, true, {
                  result: props
                });
              }
            });
          } else {
            handle = parseInt(ref, 10);
            timeout = setTimeout(function() {
              sendResponse(seq, true, {
                result: [
                  {
                    name: 'sorry',
                    value: wrapperObject('string', 'lookup timed out', false, 0, 0, 0)
                  }
                ]
              });
              return seq = 0;
            }, LOOKUP_TIMEOUT);
            return debug.request('lookup', {
              "arguments": {
                handles: [handle],
                includeSource: false
              }
            }, function(msg) {
              var obj, objProps, props, proto, refs;
              clearTimeout(timeout);
              if (msg.success && seq !== 0) {
                refs = {};
                props = [];
                if (msg.refs && Array.isArray(msg.refs)) {
                  obj = msg.body[handle];
                  objProps = obj.properties;
                  proto = obj.protoObject;
                  msg.refs.forEach(function(r) {
                    return refs[r.handle] = r;
                  });
                  props = objProps.map(function(p) {
                    var r;
                    r = refs[p.ref];
                    return {
                      name: String(p.name),
                      value: refToObject(r)
                    };
                  });
                  if (proto) {
                    props.push({
                      name: '__proto__',
                      value: refToObject(refs[proto.ref])
                    });
                  }
                }
                return sendResponse(seq, true, {
                  result: props
                });
              }
            });
          }
        } else if (methodName === 'getCompletions') {
          expr = args[0];
          data = {
            result: {},
            isException: false
          };
          if (expr === '') {
            sendResponse(seq, true, data);
            return;
          }
          return evaluate(expr, args[2], function(msg) {
            if (msg.success && msg.body.properties && msg.body.properties.length < 256) {
              msg.body.properties.forEach(function(p) {
                return data.result[p.name] = true;
              });
            }
            return sendResponse(seq, true, data);
          });
        } else {
          evalResponse = function(msg) {
            if (msg.success) {
              return sendResponse(seq, true, {
                result: refToObject(msg.body),
                isException: false
              });
            } else {
              return sendResponse(seq, true, {
                result: {
                  type: 'error',
                  description: msg.message
                },
                isException: false
              });
            }
          };
          if (methodName === 'evaluateInCallFrame') {
            return evaluate(args[1], args[0], evalResponse);
          } else if (methodName === 'evaluate') {
            return evaluate(args[0], null, evalResponse);
          }
        }
      }
    },
    disableDebugger: {
      value: function(always) {
        if (debug && debug.connected) {
          return debug.close();
        }
      }
    },
    populateScriptObjects: {
      value: function(seq) {
        return sendResponse(seq, true, {});
      }
    },
    getInspectorState: {
      value: function(seq) {
        return sendResponse(seq, true, {
          state: {
            monitoringXHREnabled: false,
            resourceTrackingEnabled: false
          }
        });
      }
    },
    getResourceContent: {
      value: function(identifier, encode) {}
    },
    enableProfiler: {
      value: function(always) {
        if (debug && debug.connected) {
          return evaluate('process.profiler !== undefined', null, function(msg) {
            if (msg.body.value) {
              return sendEvent('profilerWasEnabled');
            } else {
              sendEvent('showPanel', {
                name: 'console'
              });
              return sendEvent('addConsoleMessage', {
                messageObj: {
                  source: 3,
                  type: 0,
                  level: 2,
                  line: 0,
                  url: '',
                  repeatCount: 1,
                  message: 'you must require("v8-profiler") to use the profiler'
                }
              });
            }
          });
        } else {
          sendEvent('showPanel', {
            name: 'console'
          });
          return sendEvent('addConsoleMessage', {
            messageObj: {
              source: 3,
              type: 0,
              level: 2,
              line: 0,
              url: '',
              repeatCount: 1,
              message: 'not connected to node'
            }
          });
        }
      }
    },
    disableProfiler: {
      value: function(always) {}
    },
    clearConsoleMessages: {
      value: function() {
        return sendEvent('consoleMessagesCleared');
      }
    },
    setBreakpoint: {
      value: function(sourceID, lineNumber, enabled, condition, seq) {
        var bp, handleResponse;
        bp = breakpoints[sourceID + ':' + lineNumber];
        handleResponse = function(msg) {
          var b, data;
          if (msg.success) {
            b = msg.body;
            breakpoints[b.script_id + ':' + (b.line + 1)] = {
              sourceID: b.script_id,
              url: sourceIDs[b.script_id].url,
              line: b.line + 1,
              enabled: enabled,
              condition: condition,
              number: b.breakpoint
            };
            b.breakpoint;
            data = {
              success: true,
              actualLineNumber: b.line + 1
            };
            return sendResponse(seq, true, data);
          }
        };
        if (bp) {
          return debug.request('changebreakpoint', {
            "arguments": {
              breakpoint: bp.number,
              enabled: enabled,
              condition: condition
            }
          }, function(msg) {
            var data;
            bp.enabled = enabled;
            bp.condition = condition;
            data = {
              success: true,
              actualLineNumber: lineNumber
            };
            return sendResponse(seq, true, data);
          });
        } else {
          return debug.request('setbreakpoint', {
            "arguments": {
              type: 'scriptId',
              target: sourceID,
              line: lineNumber - 1,
              enabled: enabled,
              condition: condition
            }
          }, handleResponse);
        }
      }
    },
    removeBreakpoint: {
      value: function(sourceID, lineNumber) {
        var id;
        id = sourceID + ':' + lineNumber;
        return debug.request('clearbreakpoint', {
          "arguments": {
            breakpoint: breakpoints[id].number
          }
        }, function(msg) {
          if (msg.success) {
            return delete breakpoints[id];
          }
        });
      }
    },
    activateBreakpoints: {
      value: function() {
        return Object.keys(breakpoints).forEach(function(key) {
          var bp;
          bp = breakpoints[key];
          return debug.request('changebreakpoint', {
            "arguments": {
              breakpoint: bp.number,
              condition: bp.condition,
              enabled: true
            }
          }, function(msg) {
            if (msg.success) {
              bp.enabled = true;
              return sendEvent('restoredBreakpoint', bp);
            }
          });
        });
      }
    },
    deactivateBreakpoints: {
      value: function(injectedScriptId, objectGroup) {
        return Object.keys(breakpoints).forEach(function(key) {
          var bp;
          bp = breakpoints[key];
          return debug.request('changebreakpoint', {
            "arguments": {
              breakpoint: bp.number,
              condition: bp.condition,
              enabled: false
            }
          }, function(msg) {
            if (msg.success) {
              bp.enabled = false;
              return sendEvent('restoredBreakpoint', bp);
            }
          });
        });
      }
    },
    pause: {
      value: function() {
        return debug.request('suspend', {}, function(msg) {
          if (!msg.running) {
            return sendBacktrace();
          }
        });
      }
    },
    resume: {
      value: function() {
        debug.request('continue');
        return sendEvent('resumedScript');
      }
    },
    stepOverStatement: {
      value: function() {
        debug.request('continue', {
          "arguments": {
            stepaction: 'next'
          }
        });
        return sendEvent('resumedScript');
      }
    },
    stepIntoStatement: {
      value: function() {
        debug.request('continue', {
          "arguments": {
            stepaction: 'in'
          }
        });
        return sendEvent('resumedScript');
      }
    },
    stepOutOfFunction: {
      value: function() {
        debug.request('continue', {
          "arguments": {
            stepaction: 'out'
          }
        });
        return sendEvent('resumedScript');
      }
    },
    setPauseOnExceptionsState: {
      value: function(state, seq) {
        var params;
        params = {
          "arguments": {
            flags: [
              {
                name: 'breakOnCaughtException',
                value: state === 1
              }
            ]
          }
        };
        return debug.request('flags', params, function(msg) {
          var value;
          value = 0;
          if (msg.success) {
            if (msg.body.flags.some(function(x) {
              return x.name === 'breakOnCaughtException' && x.value;
            })) {
              value = 1;
            }
            return sendResponse(seq, true, {
              pauseOnExceptionState: value
            });
          }
        });
      }
    },
    editScriptSource: {
      value: function(sourceID, newContent, seq) {
        var args;
        args = {
          script_id: sourceID,
          preview_only: false,
          new_source: newContent
        };
        return debug.request('changelive', {
          "arguments": args
        }, function(msg) {
          var fs, match, newSource;
          sendResponse(seq, true, {
            success: msg.success,
            newBodyOrErrorMessage: msg.message || newContent
          });
          if (msg.success && config.saveLiveEdit) {
            fs = require('fs');
            match = FUNC_WRAP.exec(newContent);
            newSource = null;
            if (match && sourceIDs[sourceID] && sourceIDs[sourceID].path) {
              newSource = match[1];
              return fs.writeFile(sourceIDs[sourceID].path, newSource, function(e) {
                var data, err;
                if (e) {
                  err = e.toString();
                  data = {
                    messageObj: {
                      source: 3,
                      type: 0,
                      level: 3,
                      line: 0,
                      url: '',
                      groupLevel: 7,
                      repeatCount: 1,
                      message: err
                    }
                  };
                  return sendEvent('addConsoleMessage', data);
                }
              });
            }
          }
        });
      }
    },
    getScriptSource: {
      value: function(sourceID, seq) {
        var args;
        args = {
          "arguments": {
            includeSource: true,
            types: 4,
            ids: [sourceID]
          }
        };
        return debug.request('scripts', args, function(msg) {
          return sendResponse(seq, msg.success, {
            scriptSource: msg.body[0].source
          });
        });
      }
    },
    startProfiling: {
      value: function() {
        /*
        HACK
         * changed the behavior here since using eval doesn't profile the
         * correct context. Using as a 'refresh' in the mean time
         * Remove this hack once we can trigger a profile in the proper context
        */
        sendEvent('setRecordingProfile', {
          isProfiling: false
        });
        return this.getProfileHeaders();
      }
    },
    stopProfiling: {
      value: function() {
        return evaluate('process.profiler.stopProfiling("org.webkit.profiles.user-initiated.' + cpuProfileCount + '")', null, function(msg) {
          var obj, objProps, profile, refs;
          sendEvent('setRecordingProfile', {
            isProfiling: false
          });
          if (msg.success) {
            refs = {};
            profile = {};
            if (msg.refs && Array.isArray(msg.refs)) {
              obj = msg.body;
              objProps = obj.properties;
              msg.refs.forEach(function(r) {
                return refs[r.handle] = r;
              });
              objProps.forEach(function(p) {
                return profile[String(p.name)] = refToObject(refs[p.ref]).description;
              });
            }
            return sendProfileHeader(parseInt(profile.uid, 10), 'CPU');
          }
        });
      }
    },
    getProfileHeaders: {
      value: function() {
        evaluate('process.profiler.profileCount()', null, function(msg1) {
          var i, _i, _ref, _results;
          if (msg1.success) {
            _results = [];
            for (i = _i = 0, _ref = msg1.body.value; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push(evaluate('process.profiler.getProfile(' + i + ')', null, function(msg) {
                var obj, objProps, profile, refs;
                if (msg.success) {
                  refs = {};
                  profile = {};
                  if (msg.refs && Array.isArray(msg.refs)) {
                    obj = msg.body;
                    objProps = obj.properties;
                    msg.refs.forEach(function(r) {
                      return refs[r.handle] = r;
                    });
                    objProps.forEach(function(p) {
                      return profile[String(p.name)] = refToObject(refs[p.ref]).description;
                    });
                  }
                  return sendProfileHeader(profile.title, parseInt(profile.uid, 10), 'CPU');
                }
              }));
            }
            return _results;
          }
        });
        return evaluate('process.profiler.snapshotCount()', null, function(msg1) {
          var i, _i, _ref, _results;
          if (msg1.success) {
            _results = [];
            for (i = _i = 0, _ref = msg1.body.value; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
              _results.push(evaluate('process.profiler.getSnapshot(' + i + ')', null, function(msg) {
                var obj, objProps, profile, refs, title;
                if (msg.success) {
                  refs = {};
                  profile = {};
                  if (msg.refs && Array.isArray(msg.refs)) {
                    obj = msg.body;
                    objProps = obj.properties;
                    msg.refs.forEach(function(r) {
                      return refs[r.handle] = r;
                    });
                    objProps.forEach(function(p) {
                      return profile[String(p.name)] = refToObject(refs[p.ref]).description;
                    });
                  }
                  title = profile.title === 'undefined' ? 'org.webkit.profiles.user-initiated.' + profile.ui : profile.title;
                  return sendProfileHeader(title, parseInt(profile.uid, 10), 'HEAP');
                }
              }));
            }
            return _results;
          }
        });
      }
    },
    getProfile: {
      value: function(type, uid, seq) {
        var expr;
        expr = (function() {
          switch (type) {
            case 'HEAP':
              return 'process.profiler.findSnapshot(' + uid + ').stringify()';
            case 'CPU':
              return 'process.profiler.findProfile(' + uid + ').stringify()';
            default:
              return null;
          }
        })();
        return evaluate(expr, null, function(msg) {
          return sendResponse(seq, true, {
            profile: {
              title: 'org.webkit.profiles.user-initiated.' + uid,
              uid: uid,
              typeId: type,
              head: JSON.parse(msg.body.value)
            }
          });
        });
      }
    },
    removeProfile: {
      value: function(type, uid) {}
    },
    clearProfiles: {
      value: function() {}
    },
    takeHeapSnapshot: {
      value: function() {
        return evaluate('process.profiler.takeSnapshot()', null, function(msg) {
          var obj, objProps, profile, refs;
          if (msg.success) {
            refs = {};
            profile = {};
            if (msg.refs && Array.isArray(msg.refs)) {
              obj = msg.body;
              objProps = obj.properties;
              msg.refs.forEach(function(r) {
                return refs[r.handle] = r;
              });
              objProps.forEach(function(p) {
                return profile[String(p.name)] = refToObject(refs[p.ref]).description;
              });
            }
            return sendProfileHeader('org.webkit.profiles.user-initiated.' + profile.uid, parseInt(profile.uid, 10), 'HEAP');
          }
        });
      }
    },
    join: {
      value: function(ws_connection) {
        var _this = this;
        conn = ws_connection;
        conn.on('message', function(data) {
          return _this.handleRequest(data);
        });
        conn.on('disconnect', function() {
          _this.emit('ws_closed');
          return conn = null;
        });
        return browserConnected();
      }
    },
    handleRequest: {
      value: function(data) {
        var args, command, msg;
        msg = JSON.parse(data);
        command = this[msg.command];
        if (typeof command === 'function') {
          args = Object.keys(msg["arguments"]).map(function(x) {
            return msg["arguments"][x];
          });
          if (msg.seq > 0) {
            args.push(msg.seq);
          }
          return command.apply(this, args);
        }
      }
    }
  });
};
