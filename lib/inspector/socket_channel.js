// Generated by CoffeeScript 2.0.0-beta4
var agents, debug, fs, SocketChannel, socketChannel, wrapperObject;
fs = require('fs');
debug = require('../debug-client');
agents = require('../agents');
wrapperObject = function (type, description, hasChildren, frame, scope, ref) {
  return {
    type: type,
    description: description,
    hasChildren: hasChildren,
    objectId: '' + frame + ':' + scope + ':' + ref
  };
};
SocketChannel = function () {
  function SocketChannel(param$) {
    var cache$, instance$, this$, this$1;
    instance$ = this;
    this.sendParsedScripts = function (c) {
      return SocketChannel.prototype.sendParsedScripts.apply(instance$, arguments);
    };
    this.onPauseOrBreakpoint = function (c) {
      return SocketChannel.prototype.onPauseOrBreakpoint.apply(instance$, arguments);
    };
    {
      cache$ = param$;
      this.socketConnection = cache$.socketConnection;
      this.httpServer = cache$.httpServer;
      this.socketServer = cache$.socketServer;
    }
    console.log('[bugger] SocketChannel created');
    this.hiddenFilePatterns = [];
    debug.on('break', this.onPauseOrBreakpoint);
    this.socketConnection.on('message', (this$ = this, function (data) {
      return this$.handleRequest(JSON.parse(data.utf8Data));
    }));
    this.socketConnection.on('disconnect', (this$1 = this, function () {
      return this$1.socketConnection = null;
    }));
    this.syncBrowser();
  }
  SocketChannel.prototype.handleRequest = function (msg) {
    var agentName, args, cache$, functionName, this$;
    if (msg.method) {
      cache$ = msg.method.split('.');
      agentName = cache$[0];
      functionName = cache$[1];
      console.log('[agents.handleRequest] ' + agentName + '#' + functionName);
      args = [];
      if (msg.params)
        args.push(msg.params);
      if (msg.id > 0) {
        args.push((this$ = this, function (error, data) {
          data = 2 <= arguments.length ? [].slice.call(arguments, 1) : [];
          return this$.sendResponse(msg.id, error, data);
        }));
      } else {
        args.push(function () {
        });
      }
      return agents.invoke(agentName, functionName, args);
    } else {
      return console.log('Unknown message from frontend:', msg);
    }
  };
  SocketChannel.prototype.sendResponse = function (seq, err, data) {
    if (null == data)
      data = {};
    if (this.socketConnection) {
      return this.socketConnection.send(JSON.stringify({
        id: seq,
        error: err,
        result: data
      }));
    } else {
      return console.log('Could not send response: ', req, data);
    }
  };
  SocketChannel.prototype.dispatchEvent = function (method, params) {
    if (null == params)
      params = {};
    if (this.socketConnection) {
      return this.socketConnection.send(JSON.stringify({
        method: method,
        params: params
      }));
    } else {
      return console.log('Could not dispatch event: ', method, params);
    }
  };
  SocketChannel.prototype.syncBrowser = function () {
    var args, this$;
    args = {
      'arguments': {
        includeSource: true,
        types: 4
      }
    };
    console.log('[debug.request] scripts', args);
    return debug.request('scripts', args, (this$ = this, function (scriptsResponse) {
      var this$1;
      console.log('[debug.response] scripts');
      this$.sendParsedScripts(scriptsResponse);
      return debug.request('listbreakpoints', {}, (this$1 = this$, function (breakpointsResponse) {
        breakpointsResponse.body.breakpoints.forEach(function (bp) {
          var data;
          if (bp.type === 'scriptId') {
            data = {
              sourceID: bp.script_id,
              url: debug.sourceIDs[bp.script_id].url,
              line: bp.line,
              enabled: bp.active,
              condition: bp.condition,
              number: bp.number
            };
            return breakpoints[bp.script_id + ':' + bp.line] = data;
          }
        });
        if (!breakpointsResponse.running)
          return this$1.sendBacktrace();
      }));
    }));
  };
  SocketChannel.prototype.onPauseOrBreakpoint = function (breakDesc) {
    var args, scriptId, source;
    scriptId = null != breakDesc ? breakDesc.body.script.id : null;
    if (null != scriptId)
      source = debug.sourceIDs[scriptId];
    if (!(null != source)) {
      args = {
        'arguments': {
          includeSource: true,
          types: 4,
          ids: null != scriptId ? [breakDesc.body.script.id] : void 0
        }
      };
      debug.request('scripts', args, this.sendParsedScripts);
    } else if (null != source ? source.hidden : void 0) {
      debug.request('continue', { 'arguments': { stepaction: 'out' } });
      return;
    }
    return this.sendBacktrace();
  };
  SocketChannel.prototype.sendBacktrace = function () {
    var this$;
    return debug.request('backtrace', { 'arguments': { inlineRefs: true } }, (this$ = this, function (backtraceResponse) {
      var callFrames;
      callFrames = this$.mapCallFrames(backtraceResponse);
      return this$.dispatchEvent('Debugger.paused', { details: callFrames });
    }));
  };
  SocketChannel.prototype.mapCallFrames = function (backtraceResponse) {
    if (backtraceResponse.body.totalFrames > 0) {
      console.log(backtraceResponse.body.frames.map(function (frame, idx) {
        return '[frame ' + idx + '] ' + frame.func.scriptId.toString() + ' @ ' + frame.line + ';' + frame.column + ' (' + frame.func.inferredName + ')';
      }));
      return backtraceResponse.body.frames.map(function (frame) {
        return {
          id: frame.index,
          functionName: frame.func.inferredName,
          type: 'function',
          worldId: 1,
          location: {
            scriptId: frame.func.scriptId.toString(),
            lineNumber: frame.line,
            columnNumber: frame.column
          },
          scopeChain: frame.scopes.map(function (scope) {
            return {
              object: wrapperObject('object', frame.receiver.className, true, frame.index, scope.index, frame.receiver.ref),
              objectId: frame.index + ':' + scope.index + ':backtrace',
              type: function () {
                switch (scope.type) {
                case 1:
                  return 'local';
                case 2:
                  return 'with';
                case 3:
                  return 'closure';
                case 4:
                  return 'global';
                }
              }.call(this)
            };
          })
        };
      });
    } else {
      return [{
          type: 'program',
          location: { scriptId: 'internal' },
          line: 0,
          id: 0,
          worldId: 1,
          scopeChain: []
        }];
    }
  };
  SocketChannel.prototype.sendParsedScripts = function (scriptsResponse) {
    var paths, scripts, shorten, this$;
    scripts = scriptsResponse.body.map(function (s) {
      return {
        scriptId: String(s.id),
        url: s.name,
        data: s.source,
        startLine: s.lineOffset,
        path: String(s.name).split('/'),
        isContentScript: false
      };
    });
    scripts.sort(function (a, b) {
      return a.path.length - b.path.length;
    });
    paths = [];
    shorten = function (s) {
      var i, p;
      for (var i$ = 0, length$ = function () {
            var accum$;
            var accum$;
            accum$ = [];
            for (var i$1 = s.length - 1; s.length - 1 <= 0 ? i$1 <= 0 : i$1 >= 0; s.length - 1 <= 0 ? ++i$1 : --i$1)
              accum$.push(i$1);
            return accum$;
          }.apply(this, arguments).length; i$ < length$; ++i$) {
        i = function () {
          var accum$;
          var accum$;
          accum$ = [];
          for (var i$1 = s.length - 1; s.length - 1 <= 0 ? i$1 <= 0 : i$1 >= 0; s.length - 1 <= 0 ? ++i$1 : --i$1)
            accum$.push(i$1);
          return accum$;
        }.apply(this, arguments)[i$];
        p = s.slice(i).join('/');
        if (paths.indexOf(p) === -1) {
          paths.push(p);
          return p;
        }
      }
      return s.join('/');
    };
    return scripts.forEach((this$ = this, function (s) {
      var hidden, item, sourceMapDesc, sourceMapMatch;
      hidden = this$.hiddenFilePatterns && this$.hiddenFilePatterns.some(function (r) {
        return r.test(s.url);
      });
      sourceMapMatch = s.data.match(/\s\/\/@ sourceMappingURL=data:application\/json;base64,(.*)/);
      s.sourceMapURL = null;
      item = {
        hidden: hidden,
        path: s.url
      };
      s.url = s.path.join('/');
      item.url = s.url;
      debug.sourceIDs[s.scriptId] = item;
      debug.sourceUrls[item.url] = s.scriptId;
      if (sourceMapMatch) {
        s.sourceMapURL = '/_sourcemap/' + s.scriptId;
        sourceMapDesc = JSON.parse(new Buffer(sourceMapMatch[1], 'base64').toString('utf8'));
        sourceMapDesc.sourcesContent = sourceMapDesc.sources.map(function (sourceFile) {
          return fs.readFileSync(sourceFile, 'utf8').toString();
        });
        debug.sourceMaps[s.scriptId.toString()] = JSON.stringify(sourceMapDesc);
      }
      delete s.path;
      if (!hidden)
        return this$.dispatchEvent('Debugger.scriptParsed', s);
    }));
  };
  return SocketChannel;
}();
module.exports = socketChannel = function (opts) {
  return new SocketChannel(opts);
};
