// Generated by CoffeeScript 2.0.0-beta4
var debug, SocketChannel, socketChannel;
debug = require('../debug-client');
SocketChannel = function () {
  function SocketChannel(param$) {
    var cache$;
    {
      cache$ = param$;
      this.socketConnection = cache$.socketConnection;
      this.httpServer = cache$.httpServer;
      this.socketServer = cache$.socketServer;
    }
    console.log('[bugger] SocketChannel created');
    this.hiddenFilePatterns = [];
    this.syncBrowser();
  }
  SocketChannel.prototype.dispatchEvent = function (method, params) {
    if (null == params)
      params = {};
    if (this.socketConnection) {
      return this.socketConnection.send(JSON.stringify({
        method: method,
        params: params
      }));
    } else {
      return console.log('Could not send: ', method, params);
    }
  };
  SocketChannel.prototype.syncBrowser = function () {
    var args, this$;
    args = {
      'arguments': {
        includeSource: true,
        types: 4
      }
    };
    console.log('[debug.request] scripts', args);
    return debug.request('scripts', args, (this$ = this, function (scriptsResponse) {
      var this$1;
      console.log('[debug.response] scripts');
      this$.sendParsedScripts(scriptsResponse);
      return debug.request('listbreakpoints', {}, (this$1 = this$, function (breakpointsResponse) {
        breakpointsResponse.body.breakpoints.forEach(function (bp) {
          var data;
          if (bp.type === 'scriptId') {
            data = {
              sourceID: bp.script_id,
              url: debug.sourceIDs[bp.script_id].url,
              line: bp.line,
              enabled: bp.active,
              condition: bp.condition,
              number: bp.number
            };
            return breakpoints[bp.script_id + ':' + bp.line] = data;
          }
        });
        if (!breakpointsResponse.running)
          return this$1.sendBacktrace();
      }));
    }));
  };
  SocketChannel.prototype.sendBacktrace = function () {
    var this$;
    return debug.request('backtrace', { 'arguments': { inlineRefs: true } }, (this$ = this, function (backtraceResponse) {
      var callFrames;
      callFrames = this$.mapCallFrames(backtraceResponse);
      return this$.dispatchEvent('Debugger.paused', { details: callFrames });
    }));
  };
  SocketChannel.prototype.mapCallFrames = function (backtraceResponse) {
    if (backtraceResponse.body.totalFrames > 0) {
      console.log(backtraceResponse.body.frames.map(function (frame, idx) {
        return '[frame ' + idx + '] ' + frame.func.scriptId.toString() + ' @ ' + frame.line + ';' + frame.column + ' (' + frame.func.inferredName + ')';
      }));
      return backtraceResponse.body.frames.map(function (frame) {
        return {
          id: frame.index,
          functionName: frame.func.inferredName,
          type: 'function',
          worldId: 1,
          location: {
            scriptId: frame.func.scriptId.toString(),
            lineNumber: frame.line,
            columnNumber: frame.column
          },
          scopeChain: frame.scopes.map(function (scope) {
            return {
              object: wrapperObject('object', frame.receiver.className, true, frame.index, scope.index, frame.receiver.ref),
              objectId: frame.index + ':' + scope.index + ':backtrace',
              type: function () {
                switch (scope.type) {
                case 1:
                  return 'local';
                case 2:
                  return 'with';
                case 3:
                  return 'closure';
                case 4:
                  return 'global';
                }
              }.call(this)
            };
          })
        };
      });
    } else {
      return [{
          type: 'program',
          location: { scriptId: 'internal' },
          line: 0,
          id: 0,
          worldId: 1,
          scopeChain: []
        }];
    }
  };
  SocketChannel.prototype.sendParsedScripts = function (scriptsResponse) {
    var paths, scripts, shorten;
    scripts = scriptsResponse.body.map(function (s) {
      return {
        scriptId: String(s.id),
        url: s.name,
        data: s.source,
        startLine: s.lineOffset,
        path: String(s.name).split('/'),
        isContentScript: false
      };
    });
    scripts.sort(function (a, b) {
      return a.path.length - b.path.length;
    });
    paths = [];
    shorten = function (s) {
      var i, p;
      for (var i$ = 0, length$ = function () {
            var accum$;
            var accum$;
            accum$ = [];
            for (var i$1 = s.length - 1; s.length - 1 <= 0 ? i$1 <= 0 : i$1 >= 0; s.length - 1 <= 0 ? ++i$1 : --i$1)
              accum$.push(i$1);
            return accum$;
          }.apply(this, arguments).length; i$ < length$; ++i$) {
        i = function () {
          var accum$;
          var accum$;
          accum$ = [];
          for (var i$1 = s.length - 1; s.length - 1 <= 0 ? i$1 <= 0 : i$1 >= 0; s.length - 1 <= 0 ? ++i$1 : --i$1)
            accum$.push(i$1);
          return accum$;
        }.apply(this, arguments)[i$];
        p = s.slice(i).join('/');
        if (paths.indexOf(p) === -1) {
          paths.push(p);
          return p;
        }
      }
      return s.join('/');
    };
    return scripts.forEach(function (s) {
      var hidden, item, sourceMapMatch;
      hidden = this.hiddenFilePatterns && this.hiddenFilePatterns.some(function (r) {
        return r.test(s.url);
      });
      sourceMapMatch = s.data.match(/\s\/\/@ sourceMappingURL=data:application\/json;base64,(.*)/);
      s.sourceMapURL = null;
      if (sourceMapMatch) {
        s.sourceMapURL = '/_sourcemap/' + s.scriptId;
        sourceMaps[s.scriptId.toString()] = JSON.parse(new Buffer(sourceMapMatch[1], 'base64').toString('utf8'));
      }
      item = {
        hidden: hidden,
        path: s.url
      };
      s.url = s.path.join('/');
      item.url = s.url;
      debug.sourceIDs[s.scriptId] = item;
      debug.sourceUrls[item.url] = s.scriptId;
      delete s.path;
      if (!hidden)
        return this.dispatchEvent('Debugger.scriptParsed', s);
    });
  };
  return SocketChannel;
}();
module.exports = socketChannel = function (opts) {
  return new SocketChannel(opts);
};
