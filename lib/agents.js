// Generated by CoffeeScript 2.0.0-beta4
var _, agents, breakpoints, debug, languageMode, LOOKUP_TIMEOUT, prepareEvaluation, refToObject, throwErr, toJSONValue, wrapperObject;
debug = require('./debug-client');
_ = require('underscore');
prepareEvaluation = require('./lang').prepareEvaluation;
LOOKUP_TIMEOUT = 2500;
breakpoints = {};
languageMode = 'coffee';
throwErr = function (cb, msg) {
  return cb(null, {
    type: 'string',
    value: msg
  }, true);
};
refToObject = function (ref) {
  var desc, kids, name, subtype;
  desc = '';
  name = null;
  subtype = null;
  kids = ref.properties ? ref.properties.length : false;
  switch (ref.type) {
  case 'object':
    name = /#<(\w+)>/.exec(ref.text);
    if ((null != name ? name.length : void 0) > 1) {
      desc = name[1];
      if (desc === 'Array') {
        subtype = 'array';
        desc += '[' + (ref.properties.length - 1) + ']';
      } else if (desc === 'Buffer') {
        desc += '[' + (ref.properties.length - 4) + ']';
      }
    } else {
      desc = null != ref.className ? ref.className : 'Object';
    }
    break;
  case 'function':
    desc = null != ref.text ? ref.text : 'function()';
    break;
  default:
    desc = null != ref.text ? ref.text : '';
  }
  if (desc.length > 100)
    desc = desc.substring(0, 100) + '\u2026';
  return wrapperObject(ref.type, desc, kids, 0, 0, ref.handle, subtype);
};
wrapperObject = function (type, description, hasChildren, frame, scope, ref, subtype) {
  return {
    type: type,
    description: description,
    hasChildren: hasChildren,
    subtype: subtype,
    objectId: '' + frame + ':' + scope + ':' + ref
  };
};
toJSONValue = function (objInfo, refs) {
  var constructorFunction, properties, protoObject, prototypeObject, refMap;
  refMap = {};
  refs.forEach(function (ref) {
    return refMap[ref.handle] = ref;
  });
  switch (objInfo.type) {
  case 'object':
    constructorFunction = refMap[objInfo.constructorFunction.ref];
    prototypeObject = refMap[objInfo.prototypeObject.ref];
    protoObject = refMap[objInfo.protoObject.ref];
    properties = {};
    objInfo.properties.forEach(function (prop) {
      var propObjInfo;
      propObjInfo = _.defaults({ handle: '' + objInfo.handle + '.' + prop.name }, refMap[prop.ref]);
      return properties[prop.name] = toJSONValue(propObjInfo, refs);
    });
    return properties;
  case 'boolean':
    return objInfo.value;
  default: {
      console.log('Unknown type: ', objInfo.type);
      console.log(objInfo);
      return null;
    }
  }
};
agents = {
  Debugger: {
    enable: function (cb) {
      console.log('Debbuger#enable');
      return cb(null, true);
    },
    disable: function (cb) {
      console.log('Debbuger#disable');
      return cb(null, true);
    },
    setPauseOnExceptions: function (param$, cb) {
      var state;
      state = param$.state;
      console.log('Debugger#setPauseOnExceptions', arguments[0]);
      return cb(null, true);
    },
    setBreakpointsActive: function (param$, cb) {
      var active;
      active = param$.active;
      console.log('Debugger#setBreakpointsActive', arguments[0]);
      return cb(null, true);
    },
    removeBreakpoint: function (param$, cb) {
      var breakpointId;
      breakpointId = param$.breakpointId;
      return debug.request('clearbreakpoint', { 'arguments': { breakpoint: breakpointId } }, function (msg) {
        var id;
        for (id in breakpoints) {
          if (breakpoints[id] === breakpointId) {
            delete breakpoints[id];
            break;
          }
        }
        return cb(null);
      });
    },
    setBreakpointByUrl: function (param$, cb) {
      var args, bp, cache$, columnNumber, condition, enabled, lineNumber, sourceID, url;
      {
        cache$ = param$;
        lineNumber = cache$.lineNumber;
        url = cache$.url;
        columnNumber = cache$.columnNumber;
        condition = cache$.condition;
      }
      console.log('setBreakpointByUrl', arguments);
      enabled = true;
      sourceID = debug.sourceUrls[url];
      if (bp = breakpoints[sourceID + ':' + lineNumber]) {
        args = {
          'arguments': {
            breakpoint: bp.breakpointId,
            enabled: enabled,
            condition: condition
          }
        };
        return debug.request('changebreakpoint', args, function (msg) {
          bp.enabled = enabled;
          bp.condition = condition;
          return cb(null, bp.breakpointId, bp.locations);
        });
      } else {
        args = {
          type: 'scriptId',
          target: sourceID,
          line: lineNumber,
          enabled: enabled,
          condition: condition
        };
        return debug.request('setbreakpoint', { 'arguments': args }, function (msg) {
          var b;
          if (msg.success) {
            b = msg.body;
            bp = breakpoints[b.script_id + ':' + b.line] = {
              sourceID: b.script_id,
              url: debug.sourceIDs[b.script_id].url,
              line: b.line,
              breakpointId: b.breakpoint.toString(),
              locations: b.actual_locations.map(function (l) {
                return {
                  scriptId: l.script_id.toString(),
                  lineNumber: l.line,
                  columnNumber: l.column
                };
              }),
              enabled: enabled,
              condition: condition
            };
            return cb(null, bp.breakpointId, bp.locations);
          }
        });
      }
    },
    pause: function (cb) {
      console.log('Debugger#pause');
      return debug.request('suspend', {}, function (msg) {
        return debug.emit('break');
      });
    },
    resume: function (cb) {
      console.log('Debugger#resume');
      return debug.request('continue', {}, function (msg) {
        return cb(null, true);
      });
    },
    stepOver: function (cb) {
      return debug.request('continue', { 'arguments': { stepaction: 'next' } }, function (msg) {
        return cb(null, true);
      });
    },
    stepInto: function (cb) {
      return debug.request('continue', { 'arguments': { stepaction: 'in' } }, function (msg) {
        return cb(null, true);
      });
    },
    stepOutOfFunction: function (cb) {
      return debug.request('continue', { 'arguments': { stepaction: 'out' } }, function (msg) {
        return cb(null, true);
      });
    },
    getScriptSource: function (param$, cb) {
      var args, scriptId;
      scriptId = param$.scriptId;
      args = {
        'arguments': {
          includeSource: true,
          types: 4,
          ids: [scriptId]
        }
      };
      return debug.request('scripts', args, function (msg) {
        return cb(null, msg.body[0].source);
      });
    },
    evaluateOnCallFrame: function (options, cb) {
      var args, cache$, cache$1, callFrameId, doNotPauseOnExceptionsAndMuteConsole, expression, generatePreview, includeCommandLineAPI, objectGroup, returnByValue;
      cache$ = options;
      callFrameId = cache$.callFrameId;
      expression = cache$.expression;
      objectGroup = cache$.objectGroup;
      includeCommandLineAPI = cache$.includeCommandLineAPI;
      cache$1 = options;
      doNotPauseOnExceptionsAndMuteConsole = cache$1.doNotPauseOnExceptionsAndMuteConsole;
      returnByValue = cache$1.returnByValue;
      generatePreview = cache$1.generatePreview;
      args = {
        expression: expression,
        disable_break: doNotPauseOnExceptionsAndMuteConsole,
        global: true,
        maxStringLength: 1e5
      };
      if (null != callFrameId) {
        args.frame = callFrameId;
        args.global = false;
      }
      return debug.request('evaluate', { 'arguments': args }, function (result) {
        var resolvedObj;
        if (result.success) {
          resolvedObj = refToObject(result.body);
          if (returnByValue && !(null != resolvedObj.value))
            resolvedObj.value = toJSONValue(result.body, result.refs);
          return cb(null, resolvedObj);
        } else {
          return cb(result.message);
        }
      });
    }
  },
  Console: {
    enable: function (cb) {
      console.log('Console#enable');
      return cb(null, true);
    }
  },
  Runtime: {
    evaluate: function (options, cb, channel) {
      var args, cache$, cmd, commandMode, doNotPauseOnExceptions, expression, includeCommandLineAPI, m, objectGroup, returnByValue;
      cache$ = options;
      expression = cache$.expression;
      objectGroup = cache$.objectGroup;
      includeCommandLineAPI = cache$.includeCommandLineAPI;
      doNotPauseOnExceptions = cache$.doNotPauseOnExceptions;
      returnByValue = cache$.returnByValue;
      commandMode = /^:(\w+)$/;
      if (m = expression.match(commandMode)) {
        cmd = m[1];
        if (cmd === 'js' || cmd === 'coffee') {
          languageMode = cmd;
          return channel.console('Switched input language to ' + cmd, 'info');
        } else {
          return channel.console('Unknown command: ' + m[1], 'error');
        }
      }
      expression = prepareEvaluation(languageMode, expression);
      args = {
        expression: expression,
        disable_break: doNotPauseOnExceptions,
        global: true,
        maxStringLength: 1e5
      };
      return debug.request('evaluate', { 'arguments': args }, function (result) {
        var resolvedObj;
        if (result.success) {
          result.body.handle = expression;
          resolvedObj = refToObject(result.body);
          if (returnByValue && !(null != resolvedObj.value))
            resolvedObj.value = toJSONValue(result.body, result.refs);
          console.log('Runtime.evaluate ' + expression);
          return cb(null, resolvedObj);
        } else {
          console.log(result);
          throwErr(cb, result.message);
          return cb(null, result.message, true);
        }
      });
    },
    callFunctionOn: function (options, cb) {
      var additional_context, args, cache$, cache$1, disable_break, expression, frame, functionDeclaration, objectId, ref, returnByValue, scope;
      cache$ = options;
      objectId = cache$.objectId;
      functionDeclaration = cache$.functionDeclaration;
      returnByValue = cache$.returnByValue;
      args = options['arguments'];
      cache$1 = objectId.split(':');
      frame = cache$1[0];
      scope = cache$1[1];
      ref = cache$1[2];
      console.log('Call on ', objectId, 'returnByValue', returnByValue);
      expression = '(' + functionDeclaration + ').apply(' + ref + ', ' + JSON.stringify(args) + ');';
      disable_break = true;
      additional_context = [];
      return debug.request('evaluate', {
        'arguments': {
          expression: expression,
          disable_break: disable_break,
          additional_context: additional_context,
          global: true
        }
      }, function (result) {
        var resolvedObj;
        if (result.success) {
          resolvedObj = refToObject(result.body);
          if (returnByValue && !(null != resolvedObj.value))
            resolvedObj.value = toJSONValue(result.body, result.refs);
          return cb(null, resolvedObj);
        } else {
          return cb(result.message);
        }
      });
    },
    getProperties: function (param$, cb) {
      var cache$, cache$1, disable_break, expression, frame, functionDeclaration, getOwnProperties, handle, handles, objectId, ownProperties, ref, scope, timeout;
      {
        cache$ = param$;
        objectId = cache$.objectId;
        ownProperties = cache$.ownProperties;
      }
      cache$1 = objectId.split(':');
      frame = cache$1[0];
      scope = cache$1[1];
      ref = cache$1[2];
      if (ref === 'backtrace') {
        return debug.request('scope', {
          'arguments': {
            number: scope,
            frameNumber: frame,
            inlineRefs: true
          }
        }, function (msg) {
          var refs;
          if (msg.success) {
            refs = {};
            if (msg.refs && Array.isArray(msg.refs))
              msg.refs.forEach(function (r) {
                return refs[r.handle] = r;
              });
            return cb(null, msg.body.object.properties.map(function (p) {
              var r;
              r = refs[p.value.ref];
              return {
                name: p.name,
                value: refToObject(r)
              };
            }));
          }
        });
      } else {
        handle = parseInt(ref, 10);
        if (isNaN(handle)) {
          getOwnProperties = function () {
            var name, props;
            props = {};
            for (var cache$2 = Object.getOwnPropertyNames(this), i$ = 0, length$ = cache$2.length; i$ < length$; ++i$) {
              name = cache$2[i$];
              props[name] = this[name];
            }
            return props;
          };
          functionDeclaration = getOwnProperties.toString();
          expression = '(' + functionDeclaration + ').apply(' + ref + ', []);';
          disable_break = true;
          return debug.request('evaluate', {
            'arguments': {
              expression: expression,
              disable_break: disable_break,
              global: true
            }
          }, function (result) {
            var props, refMap;
            if (result.success) {
              refMap = {};
              result.refs.forEach(function (refDesc) {
                return refMap[refDesc.handle] = refDesc;
              });
              props = result.body.properties.map(function (pDesc) {
                var propObj;
                propObj = _.defaults({ handle: '' + ref + '[' + JSON.stringify(pDesc.name) + ']' }, refMap[pDesc.ref]);
                return {
                  name: pDesc.name,
                  value: refToObject(propObj)
                };
              });
              console.log(props);
              return cb(null, props);
            } else {
              console.log(result);
              return cb(result.message);
            }
          });
        } else {
          timeout = setTimeout(function () {
            var seq;
            cb(null, [{
                name: 'sorry',
                value: wrapperObject('string', 'lookup timed out', false, 0, 0, 0)
              }]);
            return seq = 0;
          }, LOOKUP_TIMEOUT);
          handles = [handle];
          return debug.request('lookup', {
            'arguments': {
              handles: handles,
              includeSource: false
            }
          }, function (msg) {
            var obj, objProps, props, proto, r, refs;
            clearTimeout(timeout);
            if (msg.success) {
              refs = {};
              props = [];
              if (msg.refs && Array.isArray(msg.refs)) {
                obj = msg.body[handle];
                objProps = obj.properties;
                proto = obj.protoObject;
                for (var i$ = 0, length$ = msg.refs.length; i$ < length$; ++i$) {
                  r = msg.refs[i$];
                  refs[r.handle] = r;
                }
                props = objProps.map(function (p) {
                  r = refs[p.ref];
                  return {
                    name: String(p.name),
                    value: refToObject(r)
                  };
                });
                if (proto)
                  props.push({
                    name: '__proto__',
                    value: refToObject(refs[proto.ref])
                  });
              }
              return cb(null, props);
            } else {
              return console.log('[error] Runtime#getProperties', msg);
            }
          });
        }
      }
    }
  }
};
module.exports = {
  invoke: function (agentName, functionName, args) {
    var agent, handlerFn;
    agent = agents[agentName];
    handlerFn = agent[functionName];
    return handlerFn.apply(agent, args);
  }
};
