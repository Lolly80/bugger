// Generated by CoffeeScript 2.0.0-beta5
var BackChannel, connect, createServer, forkScript, path, spawn;
spawn = require('child_process').spawn;
cache$ = require('net');
createServer = cache$.createServer;
connect = cache$.connect;
path = require('path');
BackChannel = function () {
  function BackChannel(param$) {
    var instance$;
    instance$ = this;
    this.waitForDebugger = function (a) {
      return BackChannel.prototype.waitForDebugger.apply(instance$, arguments);
    };
    this.childProcess = param$;
    this.buffer = '';
    this.connection = null;
    this.childProcess.stderr.on('data', this.waitForDebugger);
  }
  BackChannel.prototype.waitForDebugger = function (chunk) {
    var match, this$;
    this.buffer += chunk.toString();
    match = this.buffer.match(/debugger listening/);
    if (null != match) {
      this.childProcess.stderr.removeListener('data', this.waitForDebugger);
      this.buffer = null;
      return this.childProcess.debugConnection = connect(this.childProcess.debugPort, (this$ = this, function () {
        return this$.childProcess.emit('debugConnection');
      }));
    }
  };
  return BackChannel;
}();
forkScript = function (moduleName, opts, cb) {
  var tmpServer;
  tmpServer = createServer(function () {
  });
  return tmpServer.listen(0, function () {
    var childArgs, debugPort, forked, options;
    debugPort = this.address().port;
    tmpServer.close();
    childArgs = [
      '--debug-brk=' + debugPort,
      path.join(__dirname, 'script_child.js')
    ].concat(childArgs);
    options = {
      stdio: [
        'pipe',
        'pipe',
        'pipe',
        'ipc'
      ]
    };
    forked = spawn(process.argv[0], childArgs, options);
    forked.backChannel = new BackChannel(forked);
    forked.debugPort = debugPort;
    return cb(forked);
  });
};
module.exports = forkScript;
