// Generated by CoffeeScript 2.0.0-beta4
var commands, EntryScriptWrapper, EventEmitter;
EventEmitter = require('events').EventEmitter;
commands = {
  startScript: function (param$) {
    var brk, cache$, entryScript, requireScript;
    {
      cache$ = param$;
      entryScript = cache$.entryScript;
      brk = cache$.brk;
    }
    requireScript = require('../lang').requireScript;
    return requireScript(entryScript, brk === true);
  }
};
if (!(null != module.parent)) {
  process.kill(process.pid, 'SIGUSR1');
  process.on('message', function (message) {
    if (null != commands[message.code]) {
      return commands[message.code](message);
    } else {
      return console.error('[bugger] Unknown message from parent: ' + message.code, message);
    }
  });
  process.on('uncaughtException', function (error) {
    return process.send({
      code: 'uncaughtException',
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack,
        code: error.code,
        meta: error.meta
      }
    });
  });
  process.send({ code: 'childReady' });
}
EntryScriptWrapper = function (super$) {
  extends$(EntryScriptWrapper, super$);
  function EntryScriptWrapper() {
  }
  EntryScriptWrapper.prototype.forkEntryScript = function (param$, cb) {
    var backChannelHandlers, brk, cache$, cache$1, entryScript, entryScriptProc, fork, net, scriptArgs, spawn, startupFailedTimeout;
    {
      cache$ = param$;
      entryScript = cache$.entryScript;
      scriptArgs = cache$.scriptArgs;
      brk = cache$.brk;
    }
    cache$1 = require('child_process');
    spawn = cache$1.spawn;
    fork = cache$1.fork;
    net = require('net');
    entryScriptProc = fork(module.filename, scriptArgs, { silent: true });
    startupFailedTimeout = setTimeout(function () {
      throw new Error('Process for entry script failed to start');
    }, 1e3);
    module.exports.proc = entryScriptProc;
    backChannelHandlers = {
      childReady: function () {
        var debugConnection;
        if (startupFailedTimeout)
          clearTimeout(startupFailedTimeout);
        startupFailedTimeout = true;
        return debugConnection = net.connect(5858, function () {
          entryScriptProc.send({
            code: 'startScript',
            entryScript: entryScript,
            brk: brk
          });
          return cb({
            entryScriptProc: entryScriptProc,
            debugConnection: debugConnection
          });
        });
      },
      uncaughtException: function (param$1) {
        var error;
        error = param$1.error;
        return console.log('Uncaught exception in child:', error);
      }
    };
    return entryScriptProc.on('message', function (message) {
      if (null != backChannelHandlers[message.code]) {
        return backChannelHandlers[message.code](message);
      } else {
        return console.log('[bugger] Unknown message from child: ' + message.code, message);
      }
    });
  };
  return EntryScriptWrapper;
}(EventEmitter);
module.exports = new EntryScriptWrapper;
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}
function extends$(child, parent) {
  var key;
  for (key in parent)
    if (isOwn$(parent, key))
      child[key] = parent[key];
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}
