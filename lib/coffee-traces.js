// Generated by CoffeeScript 2.0.0-beta4
var coffee, compile, compileAndBreak, compileFile, ext, formatSourcePosition, fs, Module, patched, patchStackTrace, SourceMapConsumer;
fs = require('fs');
coffee = require('coffee-script-redux');
Module = require('module');
SourceMapConsumer = require('source-map').SourceMapConsumer;
patched = false;
patchStackTrace = function () {
  if (patched)
    return;
  patched = true;
  if (null != Module._sourceMaps)
    return console.error('[bugger] Someone else already has patched the stack trace.');
  Module._sourceMaps = {};
  return Error.prepareStackTrace = function (err, stack) {
    var frames, getSourceMapping, getSourceQuote, sourceFiles;
    sourceFiles = {};
    getSourceMapping = function (filename, line, column) {
      var mapString, sourceMap;
      mapString = 'function' === typeof Module._sourceMaps[filename] ? Module._sourceMaps[filename]() : void 0;
      if (mapString) {
        sourceMap = null != sourceFiles[filename] ? sourceFiles[filename] : sourceFiles[filename] = new SourceMapConsumer(mapString);
        return sourceMap.originalPositionFor({
          line: line,
          column: column
        });
      } else {
        return {
          line: line,
          column: column
        };
      }
    };
    getSourceQuote = function () {
      var cache$, cache$1, color_line, color_red, color_reset, column, errorFile, errorLines, fileLocation, fileName, frame, line, padLineNr;
      if (stack.length > 0 && !stack[0].isNative()) {
        frame = stack[0];
        if (frame.isEval()) {
          fileName = frame.getScriptNameOrSourceURL();
          if (!fileName)
            fileLocation = '' + frame.getEvalOrigin() + ', ';
        } else {
          fileName = frame.getFileName();
        }
        if (!(fileName && fileName[0] === '/'))
          return '';
        cache$ = [
          frame.getLineNumber(),
          frame.getColumnNumber()
        ];
        line = cache$[0];
        column = cache$[1];
        cache$1 = getSourceMapping(fileName, line, column);
        line = cache$1.line;
        column = cache$1.column;
        errorFile = fs.readFileSync(fileName, 'utf8').split('\n');
        color_red = '\x1b[0;31m';
        color_line = '\x1b[0;30m';
        color_reset = '\x1b[0m';
        if (!process.stdout.isTTY)
          color_red = color_line = color_reset = '';
        padLineNr = function (lineNr) {
          return new Array((line + 2).toString().length - lineNr.toString().length + 5).join(' ') + lineNr;
        };
        errorLines = function (accum$) {
          var lineNo, lineNr;
          for (var i$ = 0, length$ = function () {
                var accum$1;
                var accum$1;
                accum$1 = [];
                for (var i$1 = line - 2; line - 2 <= line + 2 ? i$1 <= line + 2 : i$1 >= line + 2; line - 2 <= line + 2 ? ++i$1 : --i$1)
                  accum$1.push(i$1);
                return accum$1;
              }.apply(this, arguments).length; i$ < length$; ++i$) {
            lineNr = function () {
              var accum$1;
              var accum$1;
              accum$1 = [];
              for (var i$1 = line - 2; line - 2 <= line + 2 ? i$1 <= line + 2 : i$1 >= line + 2; line - 2 <= line + 2 ? ++i$1 : --i$1)
                accum$1.push(i$1);
              return accum$1;
            }.apply(this, arguments)[i$];
            if (!(null != errorFile[lineNr - 1]))
              break;
            lineNo = '' + padLineNr(lineNr) + ': ';
            accum$.push(lineNr === line ? '  >' + color_line + lineNo.substr(3) + color_red + errorFile[lineNr - 1] + color_reset : '' + color_line + lineNo + color_reset + errorFile[lineNr - 1]);
          }
          return accum$;
        }.call(this, []);
        return errorLines.join('\n') + '\n';
      } else {
        return '';
      }
    };
    frames = function (accum$) {
      var frame;
      for (var i$ = 0, length$ = stack.length; i$ < length$; ++i$) {
        frame = stack[i$];
        if (frame.getFunction() === exports.runMain)
          break;
        accum$.push('  at ' + formatSourcePosition(frame, getSourceMapping));
      }
      return accum$;
    }.call(this, []);
    return '' + err.name + ': ' + (null != err.message ? err.message : '') + '\n' + frames.shift() + '\n' + getSourceQuote() + frames.join('\n') + '\n';
  };
};
formatSourcePosition = function (frame, getSourceMapping) {
  var as, column, fileLocation, fileName, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
  fileName = void 0;
  fileLocation = '';
  if (frame.isNative()) {
    fileLocation = 'native';
  } else {
    if (frame.isEval()) {
      fileName = frame.getScriptNameOrSourceURL();
      if (!fileName)
        fileLocation = '' + frame.getEvalOrigin() + ', ';
    } else {
      fileName = frame.getFileName();
    }
    fileName || (fileName = '<anonymous>');
    line = frame.getLineNumber();
    column = frame.getColumnNumber();
    source = getSourceMapping(fileName, line, column);
    fileLocation = source ? '' + fileName + ':' + source.lin + ':' + source.column + ', <js>:' + line + ':' + column : '' + fileName + ':' + line + ':' + column;
  }
  functionName = frame.getFunctionName();
  isConstructor = frame.isConstructor();
  isMethodCall = !(frame.isToplevel() || isConstructor);
  if (isMethodCall) {
    methodName = frame.getMethodName();
    typeName = frame.getTypeName();
    if (functionName) {
      tp = as = '';
      if (typeName && functionName.indexOf(typeName))
        tp = '' + typeName + '.';
      if (methodName && functionName.indexOf('.' + methodName) !== functionName.length - methodName.length - 1)
        as = ' [as ' + methodName + ']';
      return '' + tp + functionName + as + ' (' + fileLocation + ')';
    } else {
      return '' + typeName + '.' + (methodName || '<anonymous>') + ' (' + fileLocation + ')';
    }
  } else if (isConstructor) {
    return 'new ' + (functionName || '<anonymous>') + ' (' + fileLocation + ')';
  } else if (functionName) {
    return '' + functionName + ' (' + fileLocation + ')';
  } else {
    return fileLocation;
  }
};
compileFile = function (filename) {
  var cache$, code, csAst, input, jsAst, map;
  input = fs.readFileSync(filename, 'utf8');
  csAst = coffee.parse(input, { raw: true });
  jsAst = coffee.compile(csAst);
  cache$ = coffee.jsWithSourceMap(jsAst, filename);
  code = cache$.code;
  map = cache$.map;
  Module._sourceMaps[filename] = function () {
    return '' + map;
  };
  code += '\n//@ sourceMappingURL=data:application/json;base64,';
  code += new Buffer('' + map).toString('base64');
  return code += '\n';
};
compile = function (module, filename) {
  var js;
  js = compileFile(filename);
  return module._compile(js, filename);
};
compileAndBreak = function (module, filename) {
  var js;
  js = compileFile(filename);
  js = "console.error('[bugger] Execution stopped at first line');debugger;" + js;
  return module._compile(js, filename);
};
if (require.extensions)
  for (var cache$ = ['.coffee'], i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
    ext = cache$[i$];
    require.extensions[ext] = compile;
  }
module.exports = {
  compile: compile,
  compileAndBreak: compileAndBreak,
  patchStackTrace: patchStackTrace
};
