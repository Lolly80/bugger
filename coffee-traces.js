// Generated by CoffeeScript 1.6.1
(function() {
  var coffee, compile, compileAndBreak, compileFile, ext, formatSourcePosition, fs, _i, _len, _ref, _sourceMaps;

  fs = require('fs');

  coffee = require('coffee-script');

  _sourceMaps = {};

  Error.prepareStackTrace = function(err, stack) {
    var frame, frames, getSourceMapping, getSourceQuote, sourceFiles, _ref;
    sourceFiles = {};
    getSourceMapping = function(filename, line, column) {
      var mapString, sourceMap, _ref;
      mapString = _sourceMaps[filename];
      if (mapString) {
        sourceMap = (_ref = sourceFiles[filename]) != null ? _ref : sourceFiles[filename] = mapString;
        return sourceMap.getSourcePosition([line, column]);
      }
    };
    getSourceQuote = function() {
      var color_line, color_red, color_reset, column, errorFile, errorLines, fileLocation, fileName, frame, line, lineNo, lineNr, padLineNr, source;
      if (stack.length > 0 && !stack[0].isNative()) {
        frame = stack[0];
        if (frame.isEval()) {
          fileName = frame.getScriptNameOrSourceURL();
          if (!fileName) {
            fileLocation = "" + (frame.getEvalOrigin()) + ", ";
          }
        } else {
          fileName = frame.getFileName();
        }
        if (!(fileName && fileName[0] === '/')) {
          return "";
        }
        line = frame.getLineNumber();
        column = frame.getColumnNumber();
        source = getSourceMapping(fileName, line, column);
        if (source) {
          line = source[0], column = source[1];
          ++line;
        }
        errorFile = fs.readFileSync(fileName, 'utf8').split("\n");
        color_red = '';
        color_line = '';
        color_reset = '';
        if (process.stdout.isTTY) {
          color_red = '\x1B[0;31m';
          color_line = '\x1B[0;30m';
          color_reset = '\x1B[0m';
        }
        padLineNr = function(lineNr) {
          return new Array((line + 2).toString().length - lineNr.toString().length + 5).join(' ') + lineNr;
        };
        errorLines = (function() {
          var _i, _ref, _ref1, _results;
          _results = [];
          for (lineNr = _i = _ref = line - 2, _ref1 = line + 2; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; lineNr = _ref <= _ref1 ? ++_i : --_i) {
            if (errorFile[lineNr - 1] == null) {
              break;
            }
            lineNo = "" + (padLineNr(lineNr)) + ": ";
            if (lineNr === line) {
              _results.push("  >" + color_line + (lineNo.substr(3)) + color_red + errorFile[lineNr - 1] + color_reset);
            } else {
              _results.push("" + color_line + lineNo + color_reset + errorFile[lineNr - 1]);
            }
          }
          return _results;
        })();
        return errorLines.join("\n") + "\n";
      } else {
        return "";
      }
    };
    frames = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = stack.length; _i < _len; _i++) {
        frame = stack[_i];
        if (frame.getFunction() === exports.runMain) {
          break;
        }
        _results.push("  at " + (formatSourcePosition(frame, getSourceMapping)));
      }
      return _results;
    })();
    return "" + err.name + ": " + ((_ref = err.message) != null ? _ref : '') + "\n" + (frames.shift()) + "\n" + (getSourceQuote()) + (frames.join('\n')) + "\n";
  };

  formatSourcePosition = function(frame, getSourceMapping) {
    var as, column, fileLocation, fileName, functionName, isConstructor, isMethodCall, line, methodName, source, tp, typeName;
    fileName = void 0;
    fileLocation = '';
    if (frame.isNative()) {
      fileLocation = "native";
    } else {
      if (frame.isEval()) {
        fileName = frame.getScriptNameOrSourceURL();
        if (!fileName) {
          fileLocation = "" + (frame.getEvalOrigin()) + ", ";
        }
      } else {
        fileName = frame.getFileName();
      }
      fileName || (fileName = "<anonymous>");
      line = frame.getLineNumber();
      column = frame.getColumnNumber();
      source = getSourceMapping(fileName, line, column);
      fileLocation = source ? "" + fileName + ":" + (source[0] + 1) + ":" + source[1] + ", <js>:" + line + ":" + column : "" + fileName + ":" + line + ":" + column;
    }
    functionName = frame.getFunctionName();
    isConstructor = frame.isConstructor();
    isMethodCall = !(frame.isToplevel() || isConstructor);
    if (isMethodCall) {
      methodName = frame.getMethodName();
      typeName = frame.getTypeName();
      if (functionName) {
        tp = as = '';
        if (typeName && functionName.indexOf(typeName)) {
          tp = "" + typeName + ".";
        }
        if (methodName && functionName.indexOf("." + methodName) !== functionName.length - methodName.length - 1) {
          as = " [as " + methodName + "]";
        }
        return "" + tp + functionName + as + " (" + fileLocation + ")";
      } else {
        return "" + typeName + "." + (methodName || '<anonymous>') + " (" + fileLocation + ")";
      }
    } else if (isConstructor) {
      return "new " + (functionName || '<anonymous>') + " (" + fileLocation + ")";
    } else if (functionName) {
      return "" + functionName + " (" + fileLocation + ")";
    } else {
      return fileLocation;
    }
  };

  compileFile = function(filename) {
    var compiled, js, raw, sourceMap, stripped, v3SourceMap;
    raw = fs.readFileSync(filename, 'utf8');
    stripped = raw.charCodeAt(0) === 0xFEFF ? raw.substring(1) : raw;
    compiled = coffee.compile(stripped, {
      filename: filename,
      sourceMap: true,
      header: false,
      bare: true
    });
    js = compiled.js, v3SourceMap = compiled.v3SourceMap, sourceMap = compiled.sourceMap;
    v3SourceMap = JSON.parse(v3SourceMap);
    v3SourceMap.file = filename;
    v3SourceMap.sources = [filename];
    _sourceMaps[filename] = sourceMap;
    js += "//@ sourceMappingURL=data:application/json;base64,";
    js += new Buffer(JSON.stringify(v3SourceMap)).toString('base64');
    return js += "\n";
  };

  compile = function(module, filename) {
    var js;
    js = compileFile(filename);
    return module._compile(js, filename);
  };

  compileAndBreak = function(module, filename) {
    var js;
    js = compileFile(filename);
    js = "console.error('[bugger] Execution stopped at first line');debugger;" + js;
    return module._compile(js, filename);
  };

  if (require.extensions) {
    _ref = ['.coffee'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      ext = _ref[_i];
      require.extensions[ext] = compile;
    }
  }

  module.exports = {
    compile: compile,
    compileAndBreak: compileAndBreak
  };

}).call(this);
